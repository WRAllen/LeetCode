# 动态规划解题思路

先解决小问题，在解决大问题！

动态规划有几个特点（来自书本《算法图解》，本人稍作归纳）

- 每种动态规划解决方案都涉及网格（就是dp数组，可以是一维，也可以是二维的）
- 单元格中的值通常就是你要优化的值（换句话说就是你要的结果）
- 每个单元格都是一个子问题（把一个大问题，拆成很多“能直接回答的小问题”。）
- 没有放之四海皆准的计算动态规划解决方案的公式。（这是一个废话，并不能帮助什么）
根据自己的经验，补充一些
- 在求取dp数组的公式的时候，比如求dp[n]一定是和之前的n-1,或者是n-x有关系
- dp经常要都遍历一遍相关的值，才能获取到最优值，比如求取n的时候，有可能-～n-1都要判断一下


# 特殊的算法

## Kadane算法

Kadane算法扫描一次整个数列的所有数值，在每一个扫描点计算以该点数值为结束点的子数列的最大和（正数和）。该子数列由两部分组成：以前一个位置为结束点的最大子数列、该位置的数值。因为该算法用到了“最佳子结构”（以每个位置为终点的最大子数列都是基于其前一位置的最大子数列计算得出），该算法可看成动态规划的一个例子。

下面献上LeetCode的代码

```python
class Solution:
    def maxSubArray(self, nums: 'List[int]') -> 'int':
        n = len(nums)
        max_sum = nums[0]
        for i in range(1, n):
            if nums[i - 1] > 0:
                nums[i] += nums[i - 1] 
            max_sum = max(nums[i], max_sum)
        return max_sum
```

下面是具体的演算过程，

```
值：-2, 1, -3, 4, -1, 2, 1, -5, 4
和：-2  
max_sum = -2
解释：初始化
```

```
值：-2, 1, -3, 4, -1, 2, 1, -5, 4
和：-2, 1 
max_sum = 1
解释：由于上一个是-2小于0，所以当前(下标为1时)不变
```

```
值：-2, 1, -3, 4, -1, 2, 1, -5, 4
和：-2, 1, -2 
max_sum = 1
解释：由于上一个是1大于0，所以当前-3+上一个的值（1） = 2
```

```
值：-2, 1, -3, 4, -1, 2, 1, -5, 4
和：-2, 1, -2, 4 
max_sum = 4
解释：由于上一个是-3小于0，不变
```

```
值：-2, 1, -3, 4, -1, 2, 1, -5, 4
和：-2, 1, -2, 4, 3 
max_sum = 4
解释：上一个大于0，-1 + 上一个的值（4） = 3
```

```
值：-2, 1, -3, 4, -1, 2, 1, -5, 4
和：-2, 1, -2, 4,  3, 5 
max_sum = 5
解释：这里注意！！！上一个的值已由之前的-1变成3了，所以是2+3=5
```

```
值：-2, 1, -3, 4, -1, 2, 1, -5, 4
和：-2, 1, -2, 4,  3, 5, 6 
max_sum = 6
解释：与上一条同理 1 + 5= 6
```

```
值：-2, 1, -3, 4, -1, 2, 1, -5, 4
和：-2, 1, -2, 4,  3, 5, 6,  1, 
max_sum = 6
解释：同上 -5 + 6 = 1
```

```
值：-2, 1, -3, 4, -1, 2, 1, -5, 4
和：-2, 1, -2, 4,  3, 5, 6,  1, 5 
max_sum = 6
解释：同上 4 + 1 = 5
```

