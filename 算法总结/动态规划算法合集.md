# Kadane算法

Kadane算法扫描一次整个数列的所有数值，在每一个扫描点计算以该点数值为结束点的子数列的最大和（正数和）。该子数列由两部分组成：以前一个位置为结束点的最大子数列、该位置的数值。因为该算法用到了“最佳子结构”（以每个位置为终点的最大子数列都是基于其前一位置的最大子数列计算得出），该算法可看成动态规划的一个例子。

下面献上LeetCode的代码

```python
class Solution:
    def maxSubArray(self, nums: 'List[int]') -> 'int':
        n = len(nums)
        max_sum = nums[0]
        for i in range(1, n):
            if nums[i - 1] > 0:
                nums[i] += nums[i - 1] 
            max_sum = max(nums[i], max_sum)
        return max_sum
```

下面是具体的演算过程，

```
值：-2, 1, -3, 4, -1, 2, 1, -5, 4
和：-2  
max_sum = -2
解释：初始化
```

```
值：-2, 1, -3, 4, -1, 2, 1, -5, 4
和：-2, 1 
max_sum = 1
解释：由于上一个是-2小于0，所以当前(下标为1时)不变
```

```
值：-2, 1, -3, 4, -1, 2, 1, -5, 4
和：-2, 1, -2 
max_sum = 1
解释：由于上一个是1大于0，所以当前-3+上一个的值（1） = 2
```

```
值：-2, 1, -3, 4, -1, 2, 1, -5, 4
和：-2, 1, -2, 4 
max_sum = 4
解释：由于上一个是-3小于0，不变
```

```
值：-2, 1, -3, 4, -1, 2, 1, -5, 4
和：-2, 1, -2, 4, 3 
max_sum = 4
解释：上一个大于0，-1 + 上一个的值（4） = 3
```

```
值：-2, 1, -3, 4, -1, 2, 1, -5, 4
和：-2, 1, -2, 4,  3, 5 
max_sum = 5
解释：这里注意！！！上一个的值已由之前的-1变成3了，所以是2+3=5
```

```
值：-2, 1, -3, 4, -1, 2, 1, -5, 4
和：-2, 1, -2, 4,  3, 5, 6 
max_sum = 6
解释：与上一条同理 1 + 5= 6
```

```
值：-2, 1, -3, 4, -1, 2, 1, -5, 4
和：-2, 1, -2, 4,  3, 5, 6,  1, 
max_sum = 6
解释：同上 -5 + 6 = 1
```

```
值：-2, 1, -3, 4, -1, 2, 1, -5, 4
和：-2, 1, -2, 4,  3, 5, 6,  1, 5 
max_sum = 6
解释：同上 4 + 1 = 5
```

