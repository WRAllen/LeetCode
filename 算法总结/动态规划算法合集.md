# 动态规划解题思路

先解决小问题，在解决大问题！

动态规划有几个特点（来自书本《算法图解》，本人稍作归纳）

- 每种动态规划解决方案都涉及网格
- 单元格中的值通常就是你要优化的值（换句话说就是你要的结果）
- 每个单元格都是一个子问题（离散的）
- 没有放之四海皆准的计算动态规划解决方案的公式。

**注意：但仅当每个子问题都是离散的，即不依赖于其他子问题 时，动态规划才管用 **

这里个人补充一下，动态规划最重要的db数组是怎么求出来的，dp数组里面保存的值一定和你的最终答案由关系

# 特殊的算法

## Kadane算法

Kadane算法扫描一次整个数列的所有数值，在每一个扫描点计算以该点数值为结束点的子数列的最大和（正数和）。该子数列由两部分组成：以前一个位置为结束点的最大子数列、该位置的数值。因为该算法用到了“最佳子结构”（以每个位置为终点的最大子数列都是基于其前一位置的最大子数列计算得出），该算法可看成动态规划的一个例子。

下面献上LeetCode的代码

```python
class Solution:
    def maxSubArray(self, nums: 'List[int]') -> 'int':
        n = len(nums)
        max_sum = nums[0]
        for i in range(1, n):
            if nums[i - 1] > 0:
                nums[i] += nums[i - 1] 
            max_sum = max(nums[i], max_sum)
        return max_sum
```

下面是具体的演算过程，

```
值：-2, 1, -3, 4, -1, 2, 1, -5, 4
和：-2  
max_sum = -2
解释：初始化
```

```
值：-2, 1, -3, 4, -1, 2, 1, -5, 4
和：-2, 1 
max_sum = 1
解释：由于上一个是-2小于0，所以当前(下标为1时)不变
```

```
值：-2, 1, -3, 4, -1, 2, 1, -5, 4
和：-2, 1, -2 
max_sum = 1
解释：由于上一个是1大于0，所以当前-3+上一个的值（1） = 2
```

```
值：-2, 1, -3, 4, -1, 2, 1, -5, 4
和：-2, 1, -2, 4 
max_sum = 4
解释：由于上一个是-3小于0，不变
```

```
值：-2, 1, -3, 4, -1, 2, 1, -5, 4
和：-2, 1, -2, 4, 3 
max_sum = 4
解释：上一个大于0，-1 + 上一个的值（4） = 3
```

```
值：-2, 1, -3, 4, -1, 2, 1, -5, 4
和：-2, 1, -2, 4,  3, 5 
max_sum = 5
解释：这里注意！！！上一个的值已由之前的-1变成3了，所以是2+3=5
```

```
值：-2, 1, -3, 4, -1, 2, 1, -5, 4
和：-2, 1, -2, 4,  3, 5, 6 
max_sum = 6
解释：与上一条同理 1 + 5= 6
```

```
值：-2, 1, -3, 4, -1, 2, 1, -5, 4
和：-2, 1, -2, 4,  3, 5, 6,  1, 
max_sum = 6
解释：同上 -5 + 6 = 1
```

```
值：-2, 1, -3, 4, -1, 2, 1, -5, 4
和：-2, 1, -2, 4,  3, 5, 6,  1, 5 
max_sum = 6
解释：同上 4 + 1 = 5
```

