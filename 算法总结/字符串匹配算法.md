# kmp算法

KMP算法是一种改进的[字符串匹配](https://baike.baidu.com/item/字符串匹配)算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为[克努特](https://baike.baidu.com/item/克努特)—[莫里斯](https://baike.baidu.com/item/莫里斯)—[普拉特](https://baike.baidu.com/item/普拉特)操作（简称KMP算法）

时间复杂度O(M+N)

例子：

字符串 "BBC ABCDAB ABCDABCDABDE" （文本串） 里面查找 "ABCDABD"（模式串）

kmp的算法区别于暴力破解的地方是，暴力破解不会使用以及匹配上的信息

而kmp会对 模式串 进行分析，并在匹配的时候对以及匹配上的数据进行分析，从而避免了像暴力破解那样无脑的进行向右移动，kmp算法反而不会去回退文本串的指针，而是不断通过模式串的情况来调整模式串的指针

对kmp算法的[漫画解释](http://www.sohu.com/a/336648975_453160) 非常的有意思

还有一篇对kmp的解释[阮一峰的字符串匹配的KMP算法](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)也写的非常好

**kmp算法的精髓就在于构建PMT**

下面用我自己的话来解释一下 PMT（Partial Match Table 部分匹配表）的形成

```
例如：模式串 对应得匹配值
A B C D A B D
0 0 0 0 1 2 0
```

这里遇到两个问题

> 为什么要向左移动
>
> > 原理是因为，如果你遇到 模式串 的 D （最后一位的D）不匹配，去找的是 D 前面一位的 匹配值，所以这样每次都要多一步，不如直接把这个匹配值向右移动一位
>
> 为什么要在 PMT 头部添加 -1
>
> > 为了在后面的判断中方便识别是第一次循环

```
匹配值向右移动一位，并且首位赋予-1
A B C D A B D
-1 0 0 0 0 1 2
```

这样再遇到 最后一位D不匹配直接把 匹配的下标（从0开始）定位到 模式串的 2 也就是 C 的位置

下面是例子

```
父 A B C D A B C D
子 A B C D A B D
               x  这个位置不匹配 匹配下标条到2 也就是 C 的位置
父 A B C D A B C D
子         A B C D A B D
```

少匹配了好多次，这就是kmp和暴力破解的区别

下面是构建 PMT (也看到博客里面经常有人叫做next数组)的代码

```python
# 下面这个构建PMT的代码好像是祖传代码，但是这个有个先前条件，就是 首位必须是-1
# p 是 模式串
def getNext(self, p):
    nex = [0] * len(p)
    # 这里如果是0 的话会陷入死循环
    nex[0] = -1
    i = 0
    j = -1
    while i < len(p) - 1:
        if j == -1 or p[i] == p[j]:
            i += 1
            j += 1
            nex[i] = j 
        else:
            j = nex[j]
    return nex
```

看完这个祖传代码我是一头雾水，于是我用麻烦一点的方法构建了这个 PMT

```python
def getNextBySelf(self, needle):
    list_length = len(needle)
    # 先创建了一个全是0的PMT
    next = [0] * list_length
    # 循环获取对应得字符串 例如 ABCDABD
    for i in range(list_length):
        # 当 i = 0 的时候 check_list = []
        # 当 i = 1 的时候 check_list = "A"
        # 当 i = 2 的时候 check_list = "AB"
        # 以此类推
        check_list = needle[0:i+1]
        # 获取 check_list 的前缀集合 
        # 例如check_list = "AB" 时 获取 "A"
        bef_list = set(check_list[0:i+1] for i in range(len(check_list)-1))
        # 获取 check_list 的后缀集合 
        aft_list = set(check_list[1+i:] for i in range(len(check_list)-1))
        # 取集合的交集
        int_list = list(bef_list.intersection(aft_list))
        # 把交集里面最大的长度赋予next数组
        next[i] = len(max(int_list)) if int_list else 0
    # 上面介绍的首位添加-1， 和右移next数组
    next.insert(0, -1)
    next.pop()
    return next
```

#### 结合LeetCode的题目[28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)

下面就是对应得解答

```python
class Solution:
    # 判断主体函数
    def strStr(self, haystack: str, needle: str) -> int:
        # 如果不含模式串就直接返回-1
        if needle not in haystack: return -1
        if not needle: return 0
        nexts = self.getNextBySelf(needle)
        hays_index = 0
        next_index = 0 
        # 单两个指针都小于列表长度时循环
        while hays_index < len(haystack) and next_index < len(needle):
            # 只有第一次 或者是 两个字符串的字符相等 才会往后走
            if next_index == -1 or haystack[hays_index] == needle[next_index]:
                hays_index += 1
                next_index += 1
            # 如果不相等 就调用next数组的值进行next_index的回滚
            else:
                next_index = nexts[next_index]
        # 因为要求返回匹配到的开始下标，所以有了下面的判断
        if next_index == len(needle):
            return hays_index - next_index
        return -1
    
	# 上面介绍的获取next数组函数
    def getNextBySelf(self, needle):
        list_length = len(needle)
        next = [0] * list_length
        for i in range(list_length):
            check_list = needle[0:i+1]
            bef_list = set(check_list[0:i+1] for i in range(len(check_list)-1))
            aft_list = set(check_list[1+i:] for i in range(len(check_list)-1))
            int_list = list(bef_list.intersection(aft_list))
            next[i] = len(max(int_list)) if int_list else 0
        next.insert(0, -1)
        next.pop()
        return next
```

运行结果

```
执行用时 :24 ms, 在所有 python3 提交中击败了99.68% 的用户
内存消耗 :12.7 MB, 在所有 python3 提交中击败了99.53%的用户

执行用时 :32 ms, 在所有 python3 提交中击败了95.43% 的用户
内存消耗 :12.7 MB, 在所有 python3 提交中击败了99.53%的用户

执行用时 :32 ms, 在所有 python3 提交中击败了95.43% 的用户
内存消耗 :12.8 MB, 在所有 python3 提交中击败了99.53%的用户
```



# BM算法

在[计算机科学](https://baike.baidu.com/item/计算机科学/9132)里，**Boyer-Moore字符串搜索算法**是一种非常高效的[字符串搜索算法](https://baike.baidu.com/item/字符串搜索算法/6287150)。它由Bob Boyer和J Strother Moore设计于1977年。BM算法(Boyer-Moore)不仅效率高，而且构思巧妙，是十分有效的字符串匹配算法，比KMP算法要更加高效。

时间复杂度最差和KMP一样 最佳是O(n)

与KMP算法一样，不去理会 文本串，而是在匹配前先对 模式串 进行处理

具体可看下面大佬的说明，写的非常好

[阮一峰的字符串匹配的Boyer-Moore算法](http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html)

