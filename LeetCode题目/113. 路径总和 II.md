# é¢˜ç›®[113. è·¯å¾„æ€»å’Œ II](https://leetcode.cn/problems/path-sum-ii/description/)

ç»™ä½ äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root å’Œä¸€ä¸ªæ•´æ•°ç›®æ ‡å’Œ targetSum ï¼Œæ‰¾å‡ºæ‰€æœ‰ ä»æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹ è·¯å¾„æ€»å’Œç­‰äºç»™å®šç›®æ ‡å’Œçš„è·¯å¾„ã€‚

å¶å­èŠ‚ç‚¹ æ˜¯æŒ‡æ²¡æœ‰å­èŠ‚ç‚¹çš„èŠ‚ç‚¹ã€‚

 

ç¤ºä¾‹ 1ï¼š

![1](https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg)


    è¾“å…¥ï¼šroot = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
    è¾“å‡ºï¼š[[5,4,11,2],[5,8,4,5]]


ç¤ºä¾‹ 2ï¼š

![2](https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg)

    è¾“å…¥ï¼šroot = [1,2,3], targetSum = 5
    è¾“å‡ºï¼š[]

ç¤ºä¾‹ 3ï¼š

    è¾“å…¥ï¼šroot = [1,2], targetSum = 0
    è¾“å‡ºï¼š[]

æç¤º:

    æ ‘ä¸­èŠ‚ç‚¹æ€»æ•°åœ¨èŒƒå›´ [0, 5000] å†…
    -1000 <= Node.val <= 1000
    -1000 <= targetSum <= 1000

*****

# è§£é¢˜æ€è·¯

å’Œæœ¬é¢˜ç›¸å…³çš„

[112. è·¯å¾„æ€»å’Œ](https://leetcode.cn/problems/path-sum/description/)


å»ºè®®å…ˆåšå®Œè¿™1é¢˜å†æ¥åšè¿™ä¸€é¢˜ğŸ˜Š

å‰ç½®é¢˜åªæ˜¯è¿”å›ä¸€ä¸ªtrue or falseï¼Œåªéœ€è¦åˆ¤æ–­æœ‰ä¸€æ¡è·¯æ˜¯é€šçš„å°±è¡Œï¼Œæœ¬é¢˜å°±æ˜¯è¦æŠŠæ‰€æœ‰çš„â€œè·¯â€éƒ½æ‰¾å‡ºæ¥

112è¿™é¢˜ä¹‹å‰çš„è§£æ³•æ˜¯ï¼š[112é¢˜è§£](./112.%20è·¯å¾„æ€»å’Œ.md) ä¹Ÿæ˜¯ä¸€ä¸ªéå¸¸å…¸å‹çš„å›æº¯ç®—æ³•ï¼Œé€šè¿‡å°è¯•çš„æ–¹å¼å»æ‰¾åˆ°å¯¹åº”çš„å€¼

é‚£æœ¬é¢˜å°±æ˜¯æŠŠæ‰€æœ‰å°è¯•è¿‡ï¼Œèƒ½è¾¾æˆç›®æ ‡çš„â€œè·¯â€éƒ½å­˜å‚¨èµ·æ¥å°±è¡Œäº†

å¯ä»¥å†å¤ä¹ ä¸€ä¸‹å…¬å¼[å›æº¯è§£é¢˜æ€è·¯](../ç®—æ³•æ€»ç»“/å›æº¯è§£é¢˜æ€è·¯.md)

## è§£æ³•1 å›æº¯:

æ ¹æ®å›æº¯è§£é¢˜æ€è·¯ï¼Œç»“åˆ112çš„ç­”æ¡ˆï¼Œå¾ˆå®¹æ˜“å°±å†™å‡ºäº†ä¸‹é¢ä»£ç ï¼ˆä»£ç ä¸å¯¹ï¼Œå…·ä½“åé¢ä¼šè¯´ï¼‰

### golangä»£ç 1

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func pathSum(root *TreeNode, targetSum int) [][]int {
    // å£°æ˜å›æº¯å‡½æ•°
    var backtrack func(root *TreeNode, targetSum int)
    // æœ€ç»ˆç»“æœ
    result := make([][]int, 0)
    // æ¯æ¬¡å›æº¯è¦ç”¨åˆ°çš„ç»“æœ
    each_result := make([]int, 0)
    // å®šä¹‰å…·ä½“çš„å›æº¯å‡½æ•°
    backtrack = func(root *TreeNode, targetSum int) {
        // å…¬å¼ï¼š if æ»¡è¶³ç»“æŸæ¡ä»¶: 
        if root == nil{
            // å¦‚æœtargetSumç­‰äº0è¯´æ˜å½“å‰each_resulté‡Œé¢çš„å€¼å°±æ˜¯ç»“æœè¦çš„
            // å¯ä»¥åŠ å…¥æœ€ç»ˆç­”æ¡ˆé‡Œé¢ï¼Œè¿™é‡Œä¸ºäº†é¿å…å›æº¯å¯¼è‡´ç»“æœæ··ä¹±ï¼Œæµ…æ‹·è´ä¸€ä»½
            if targetSum == 0 {
                tmp := make([]int, len(each_result))
                // è€æ˜¯å¿˜è®°copyçš„æºå¤´æ˜¯å“ªä¸ªï¼Œæ˜¯copy(dst, src)
                // Go çš„è®¾è®¡å“²å­¦ï¼šâ€œå…ˆç›®æ ‡ï¼Œåæ¥æºâ€,ä¾‹å¦‚appendä¹Ÿæ˜¯è¿™æ ·
                // å’Œ Unix / C ä¼ ç»Ÿæ˜¯ä¸€è„‰ç›¸æ‰¿çš„ï¼Œéƒ½æ˜¯å…ˆç›®çš„ï¼Œå†æºå¤´
                copy(tmp, each_result)
                result = append(result, tmp)
            }
            return
        }
        // å…¬å¼ï¼šfor é€‰æ‹© in é€‰æ‹©åˆ—è¡¨:

    }
    backtrack(root, targetSum)
    return result
}

```

ä½†æ˜¯ç°åœ¨é‡åˆ°é—®é¢˜äº†ï¼Œå…¬å¼é‡Œé¢çš„åšé€‰æ‹©åœ¨è¿™é‡Œè¦æ€ä¹ˆæå‘¢ï¼Ÿ

ç†è®ºä¸Šåº”è¯¥æ˜¯å…ˆè¯•ä¸€ä¸‹Leftè¿™è¾¹ï¼Œç„¶åå†è¯•ä¸€ä¸‹Rightè¿™è¾¹ï¼Œä½†æ˜¯å…¬å¼é‡Œé¢æ˜¯ä¸ªforå¾ªç¯å‘¢ï¼Œ

é‚£ä¼ªä»£ç åº”è¯¥æ˜¯è¿™æ ·
```python
for each in [Left, Right]
    åšé€‰æ‹©
    backtrack(each, targetSum)
    æ’¤é”€é€‰æ‹©
```

ç¿»è¯‘æˆgoå°±æ˜¯ä¸‹é¢
```go
children := []*TreeNode{root.Left, root.Right}
for _, each := range(children){
    åšé€‰æ‹©
    backtrack(each, targetSum)
    æ’¤é”€é€‰æ‹©
}
```
é‚£é—®é¢˜å˜æˆåšä»€ä¹ˆé€‰æ‹©å‘¢? å›åˆ°é€»è¾‘æœ¬èº«ï¼Œå½“å‰çš„rootè¦æ€ä¹ˆå¤„ç†å‘¢ï¼Œæ˜¯ä¸æ˜¯targetSumè¦å‡å»å½“å‰rootçš„å€¼ï¼Œ
å¹¶ä¸”è¦æŠŠrootä¸¢åˆ°each_resulté‡Œé¢

ä½†æ˜¯ç»†æƒ³ä¸€ä¸‹ï¼Œä¸å¯¹åŠ²å‘€ï¼Œä¸ºå•¥æˆ‘åšLeftæˆ–è€…Rightçš„é€‰æ‹©çš„æ—¶å€™ï¼Œä¼šå’Œrootæ‰¯ä¸Šå…³ç³»å‘¢ï¼Œè¿™æ¬¡çš„é€‰æ‹©åº”è¯¥æ˜¯åŸºäºleftæˆ–è€…rightçš„æ‰å¯¹

ä½†æ˜¯å®é™…ä¸Šï¼Œå†åˆ¤æ–­leftæˆ–è€…rightçš„æ—¶å€™ï¼Œé€‰æ‹©å·²ç»åšå‡ºæ¥äº†ï¼Œåšçš„æ˜¯å½“å‰rootçš„é€‰æ‹©

å› ä¸ºåˆ°forè¿™ä¸€æ­¥çš„æ—¶å€™ï¼Œå…¶å®é»˜è®¤rootå·²ç»æ˜¯è¢«é€‰ä¸­çš„â€œè·¯â€ï¼ˆè¿™é‡Œå¾ˆå¥½ç†è§£ï¼Œæˆ‘éƒ½å¼€å§‹åˆ¤æ–­leftå’Œrightäº†ï¼Œé‚£rootè‚¯å®šæ˜¯è¢«åŒ…å«è¿›å»çš„ï¼‰

é‚£ã€Šåšé€‰æ‹©ã€‹ è¿™æ­¥å°±è¦æŒªåŠ¨åˆ°forçš„å¤–é¢ï¼Œæ’¤é”€ä¸å˜ï¼Œé‚£ä¸Šé¢çš„ã€Šå…¬å¼ï¼š if æ»¡è¶³ç»“æŸæ¡ä»¶ã€‹ï¼Œä¹Ÿè¦æ˜¯é’ˆå¯¹å½“å‰rootçš„

ä»£ç å¦‚ä¸‹
```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func pathSum(root *TreeNode, targetSum int) [][]int {
    // å£°æ˜å›æº¯å‡½æ•°
    var backtrack func(root *TreeNode, targetSum int)
    // æœ€ç»ˆç»“æœ
    result := make([][]int, 0)
    // æ¯æ¬¡å›æº¯è¦ç”¨åˆ°çš„ç»“æœ
    each_result := make([]int, 0)
    // å®šä¹‰å…·ä½“çš„å›æº¯å‡½æ•°
    backtrack = func(root *TreeNode, targetSum int) {
        if root == nil{
            return
        }
        targetSum -= root.Val
        each_result = append(each_result, root.Val)
        // è¿™é‡Œæ˜¯ å…¬å¼ï¼š if æ»¡è¶³ç»“æŸæ¡ä»¶ è¿™å—
        // å¦‚æœå½“å‰rootèƒ½è®©targetSumä¸º0ï¼Œå¹¶ä¸”å½“å‰rootæ˜¯å¶å­èŠ‚ç‚¹
        // é‚£è¯´æ˜å°±æ˜¯è¦çš„ç»“æœï¼ŒæŠŠeach_resultæ”¾å…¥æœ€ç»ˆç»“æœé‡Œ
        if targetSum == 0 && root.Left == nil && root.Right == nil{
            tmp := make([]int, len(each_result))
            copy(tmp, each_result)
            result = append(result, tmp)
            return
        }
        // å…¬å¼ï¼šfor é€‰æ‹© in é€‰æ‹©åˆ—è¡¨:
        for _, each := range([]*TreeNode{root.Left, root.Right}){
            if each == nil {
                continue
            }
            backtrack(each, targetSum)
            // âš ï¸ ä¸‹é¢è¿™é‡Œå¾ˆé‡è¦
            // è¿™é‡Œæ’¤é”€çš„ä¸æ˜¯å½“å‰rootçš„é€‰æ‹©ï¼Œè€Œæ˜¯backtracké‡Œé¢eachçš„é€‰æ‹©
            each_result = each_result[:len(each_result)-1]
        }
    }
    backtrack(root, targetSum)
    return result
}

```

è¿è¡Œç»“æœ
```
æ‰§è¡Œç”¨æ—¶åˆ†å¸ƒ
0ms å‡»è´¥100.00%

æ¶ˆè€—å†…å­˜åˆ†å¸ƒ
6.16MB å‡»è´¥70.91%
```

### pythonä»£ç 1

ç…§å¸¸ç¿»è¯‘ä¸ºpythonï¼Œå†å†™ä¸€éï¼ŒåŠ æ·±å°è±¡ï¼Œé¡ºä¾¿å¤ä¹ pytonè¯­æ³•[doge]

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def pathSum(self, root: Optional[TreeNode], targetSum: int) -> List[List[int]]:
        result = []
        each_result = []
        def backtrack(root, target_sum):
            if not root: return
            target_sum -= root.val
            each_result.append(root.val)
            if target_sum == 0 and not root.left and not root.right:
                result.append(each_result.copy())
            for each in [root.left, root.right]:
                if not each: continue
                backtrack(each, target_sum)
                # è¿™é‡Œç”¨each_result = each_result[:-1]ä¼šè§¦å‘UnboundLocalErroré”™è¯¯
                # each_result = ä¼šæŠŠè¯¥å˜é‡å½“æˆå±€éƒ¨å˜é‡
                # å¦‚æœä¸€å®šè¦ç”¨ä¸Šé¢è¿™ç§ï¼Œåœ¨backtracké‡Œé¢åŠ ä¸Šnonlocal each_resultå£°æ˜ä¸æ˜¯å±€éƒ¨å˜é‡
                each_result.pop()
        backtrack(root, targetSum)
        return result
```

è¿è¡Œç»“æœ
```
æ‰§è¡Œç”¨æ—¶åˆ†å¸ƒ
0ms å‡»è´¥100.00%

æ¶ˆè€—å†…å­˜åˆ†å¸ƒ
17.91MB å‡»è´¥98.55%
```

æ¬¢è¿æ¥githubä¸Šçœ‹æ›´å¤šé¢˜ç›®çš„è§£ç­”[åŠ›æ‰£è§£é¢˜æ€è·¯](https://github.com/WRAllen/LeetCode)
