# 题目[138. 随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/description/?envType=study-plan-v2&envId=top-100-liked)

给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点 。

例如，如果原链表中有 X 和 Y 两个节点，其中 X.random --> Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random --> y 。

返回复制链表的头节点。

用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：

    val：一个表示 Node.val 的整数。
    random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为  null 。

你的代码 只 接受原链表的头节点 head 作为传入参数。

示例 1：
![1](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e1.png)


    输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
    输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]

示例 2：
![2](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e2.png)


    输入：head = [[1,1],[2,1]]
    输出：[[1,1],[2,1]]


示例 3：

![3](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/01/09/e3.png)


    输入：head = [[3,null],[3,0],[3,null]]
    输出：[[3,null],[3,0],[3,null]]
 

提示：

    0 <= n <= 1000
    -104 <= Node.val <= 104
    Node.random 为 null 或指向链表中的节点。

*****

# 解题思路

本题要做的事情已经很清楚了，复制一个链表，这里就不再赘述了，难点在哪里呢，其实就是有个random指针，

这个指针会随机指向一个节点，这个节点可能是最后一位，所以在复制链表的时候，如何优雅的处理掉这个random指针

应该就是本题的考点

## 解法1 暴力破解:

有点忘记链表的复制是怎么复制了，先解决假如没有random时，只有val和next时，链表是怎么复制的

那又要遇到一个问题，如何能构造一个链表（因为本人喜欢在本地的vscode上面debug，ok了才会放到leetcode上）

问题的核心就是，比如我有一个链表{7, 13, 11, 10, 4},我在组织这个链表的时候的next怎么赋值

这个看起来就是一个递归要做的事情，具体代码如下
```go
type Node struct {
    Val int
    Next *Node
}

func formatNode(data []int) *Node {
    if len(data) > 0 {
        node := &Node{
        	Val:    data[0],
        }
        node.Next = formatNode(data[1:])
        return node
    }
    return nil
}

func printNode(head *Node) {
    for head != nil {
        fmt.Println("Node val:", head.Val)
        head = head.Next
    }
}


func main() {
    data := []int{7, 13, 14, 10,1}
    head := formatNode(data)
    printNode(head)
}
```

那怎么复制一个链表呢，其实和上面这个思路是一样的，用递归构造Node，递归函数使用原Node数据

具体如下
```go
func copyRandomList(head *Node) *Node {
    if head == nil {
        return nil
    }  
    // 创建一个新的head
    newHead := &Node{
    	Val:    head.Val,
    } 
    // 新head的next用copyList返回的node链接上
    newHead.Next = copyList(head.Next)
    return newHead
}


func copyList(nextNode *Node) *Node {
    // 如果当前的node不为空
    if nextNode != nil {
        // 根据当前的node的值创建一个新的node
        newNode := &Node{
        	Val:    nextNode.Val,
        }
        // 新node的next递归调用函数本身，把原始node的next传入
        newNode.Next = copyList(nextNode.Next)
        // 返回这个新node
        return newNode
    }
    return nil
}
```

现在我们知道如何复制一个链表了，那问题就变成如何处理这个random，如果还是一次循环，难点就在于，传入的head他是一个已经构建好的NodeList

而我们在复制的时候就会遇到一个问题，比如复制第一个node的时候，假如random指向了最后一个node，但是我们复制的时候还没构建到最后一个node

如果提前构建了这个node，当倒数第二个的next指向的时候应该要知道这个node已经构建了，而不是去new一个，这个判断有点难。

那什么结构体可以做这个是否存在的判断呢？相比大家都知道用字典，value肯定就是这个node，那key是啥呢？

用旧节点作为key，其实一下子想不到，但是也没有其他能作为独立标识的了，要唯一，新node还没创建，

那就只能用旧的node，旧的node的val会重复，肯定不能用，那就只有旧node的地址了，他可以为一标识

这里也是用到了递归的思路，把当前的node和新node，写到字典的key和value里面，然后递归进行赋值

这里有个思路，是递归这边比较好解释的，比如我Next用递归赋值，那递归到最后一层，他肯定是个

《把当前的node和新node，写到字典的key和value里面》 然后他回溯到上一层的时候，对random进行赋值，

那最底层那边都已经创建好了，当然对random进行赋值的时候自然就可能找到这个新节点了，说的有点乱

直接上代码

### golang代码1

```go
// 存储旧node和新node的对应关系
var nodeInfo map[*Node]*Node

func copyRandomList(head *Node) *Node {
    if head == nil{
        return nil
    }
    nodeInfo = make(map[*Node]*Node, 0)
    newNode := dfs(head)
    newNode.Next = dfs(head.Next)
    newNode.Random = dfs(head.Random)
    return newNode
}


func dfs(head *Node) *Node {
    if head == nil {
        return nil
    }
    // 旧node和新node是一一对应的，就可以把这个用做next和random时node是否存在的判断依据
    // 如果存在了，说明之前创建过，直接return
    if n, ok := nodeInfo[head]; ok {
        return n
    }
    // 不存在就创建一个新node
    newNode := Node{
        Val: head.Val,
    }
    // 把新node放入字典里面
    nodeInfo[head] = &newNode
    // 其他的就是迭代的老套路了
    newNode.Next = dfs(head.Next)
    newNode.Random = dfs(head.Random)
    return &newNode
}

```

运行结果
```
执行用时分布
4ms 击败12.91%

消耗内存分布
5.34MB 击败7.89%
```

### python代码1

下面把go代码翻译为python

```python
class Solution:
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        if head is None:
            return None
        self.nodeInfo = {}
        newNode = self.dfs(head)
        newNode.next = self.dfs(head.next)
        newNode.random = self.dfs(head.random)
        return newNode
        

    def dfs(self, head):
        if head is None:
            return None
        if head in self.nodeInfo:
            return self.nodeInfo[head]
        newNode = Node(head.val)
        self.nodeInfo[head] = newNode
        newNode.next = self.dfs(head.next)
        newNode.random = self.dfs(head.random)
        return newNode
```

运行结果
```
执行用时分布
47ms 击败56.37%

消耗内存分布
18.48MB 击败16.32%
```

欢迎来github上看更多题目的解答[力扣解题思路](https://github.com/WRAllen/LeetCode)
