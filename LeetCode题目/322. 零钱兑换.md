# 题目[322. 零钱兑换](https://leetcode.cn/problems/coin-change/description/?envType=study-plan-v2&envId=top-100-liked)

给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。

计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。

你可以认为每种硬币的数量是无限的。

 

示例 1：

    输入：coins = [1, 2, 5], amount = 11
    输出：3 
    解释：11 = 5 + 5 + 1
示例 2：

    输入：coins = [2], amount = 3
    输出：-1
示例 3：

    输入：coins = [1], amount = 0
    输出：0
 

提示：

    1 <= coins.length <= 12
    1 <= coins[i] <= 2^31 - 1
    0 <= amount <= 10^4

*****

# 解题思路

刚刚好前面做的是动态规划的题目，设计到了这块，之前还总结[贪心和动态的区别](../算法总结/动态规划和贪心算法的区别.md)里面用到的求硬币的例子就是这题


## 解法1 动态规划:

动态规划，最重要的就是dp数组，具体dp里面存什么其实也是确定的

dp里面存的就是n时的答案，这题和[279. 完全平方数](https://leetcode.cn/problems/perfect-squares/description/?envType=study-plan-v2&envId=top-100-liked)其实是一样的,

也就是dp里面存储的就是当输入的amount为n时，最少能凑成这个n的数量

那每个dp里面怎么得出来呢？

比如：coins = [1, 2, 5], amount = 11

那我们就可以这样

dp[11] = dp[11-5], dp[11-2], dp[11-1] + 1

也就是dp[11]的时候，我们有3种情况，比如dp[6]+1, dp[9]+1, dp[10]+1，英文dp[6]的时候我+5这个coin就能满足amount为11了，dp[9]和dp[10]同理

所以我们只要从dp[6],dp[9],dp[10]里面取个最小的就行，具体看代码

### golang代码

```go
func coinChange(coins []int, amount int) int {
	// 没有0元的硬币:D
	if amount == 0 {
		return -1
	}

	// 先初始化amount+1个dp数组，这里+1因为amount这个时候不会为0
	dp := make([]int, amount+1)
	for i := 1; i <= amount; i++{
		minNum := math.MaxInt32
		perfectFind := false
		// 循环所有的coin，获取dp[i-coin]的情况
		for _, coin := range coins {
			// 当coin比i还大时，直接continue
			if coin > i {
				continue
			}
			if coin == i {
				perfectFind = true
			}
			if dp[i-coin] < minNum && dp[i-coin] != 0 {
				minNum = dp[i-coin]
			}
		}
		if perfectFind {
			dp[i] = 1
		} else {
			// 说明有合署的coin
			if minNum != math.MaxInt32{
				// 这个1就是coin里面任意一个
				dp[i] = minNum + 1
			}
		}
	}
	if dp[amount] == 0 {
		return -1
	}
	return dp[amount]
}
```

运行！

运行结果
```
解答错误
187 / 189 个通过的测试用例

官方题解
输入
coins = [1]
amount = 0


输出 -1
预期结果 0
```

我靠，amount为0时为啥不是-1，绝了

修改第一行的判断，当amount是0是，直接返回0

```go
func coinChange(coins []int, amount int) int {
	// 没有0元的硬币但是要返回 :(
	if amount == 0 {
		return 0
	}

	// 先初始化amount+1个dp数组，这里+1因为amount这个时候不会为0
	dp := make([]int, amount+1)
	for i := 1; i <= amount; i++{
		minNum := math.MaxInt32
        // 标记是否有coin直接等于i的
		perfectFind := false
		// 循环所有的coin，获取dp[i-coin]的情况
		for _, coin := range coins {
			// 当coin比i还大时，直接continue
			if coin > i {
				continue
			}
            // 如果coin直接等于i，那么后续直接+1就行
			if coin == i {
				perfectFind = true
			}
            // 如果i-coin的dp里面有比minNum小的，但是又不等于0（因为0是初始化的，并且本来小于MaxInt32）
			if dp[i-coin] < minNum && dp[i-coin] != 0 {
				minNum = dp[i-coin]
			}
		}
		if perfectFind {
			dp[i] = 1
		} else {
			// 说明有合适的coin
			if minNum != math.MaxInt32{
				// 这个1就是coin里面任意一个
				dp[i] = minNum + 1
			}
		}
	}
    // 都没合适的，直接返回-1
	if dp[amount] == 0 {
		return -1
	}
	return dp[amount]
}
```

运行结果
```
执行用时分布
15ms 击败25.48%

消耗内存分布
7.95MB 击败50.04%
```

代码略显繁琐，看了一下[官方的解答](https://leetcode.cn/problems/coin-change/solutions/132979/322-ling-qian-dui-huan-by-leetcode-solution/?envType=study-plan-v2&envId=top-100-liked),说实话没看到，于是把代码copy到gpt里面，让gpt老师来教我

发现他的初始化相当的妙，下面直接上代码

```go
func coinChange(coins []int, amount int) int {
	// 初始化dp数组，除了0是0外，其他都是MaxInt32
	dp := make([]int, amount+1)
	for i := 1; i <= amount; i++ {
		dp[i] = math.MaxInt32
	}
	// 遍历每个coin，获取coin能组成的case
	for _, coin := range coins{
		// 这些coin他能组成的case，只有值再[coin, amount]之间
		for i := coin; i <= amount; i++ {
			// 这里和之前一样，当前amount为i时， i-coin就是当前选的coin，就能凑满i了
			// 至于这个i-coin之前的情况，dp里面记录了
			dp[i] = min(dp[i], dp[i-coin]+1)
		}
	}
	if dp[amount] == math.MaxInt32{
		return -1
	}
	return dp[amount]
}
```

运行结果
```
执行用时分布
5ms 击败92.78%

消耗内存分布
8.01MB 击败33.76%
```

哇哦，从25ms变成5ms了，牛逼

### python代码

python自己再写一遍

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        dp = [float("inf")] * (amount + 1)
        dp[0] = 0
        for coin in coins:
            for i in range(coin, amount + 1):
                dp[i] = min(dp[i], dp[i-coin] + 1)
        return dp[amount] if dp[amount] != float("inf") else -1
        
```

运行结果
```
执行用时分布
427ms 击败97.76%

消耗内存分布
19.57MB 击败25.29%
```

### rust代码

rust来啦～

```rust
impl Solution {
    pub fn coin_change(coins: Vec<i32>, amount: i32) -> i32 {
        // rust里面的index要是usize
        let amount = amount as usize;
        let mut dp = vec![i32::MAX; amount+1];
        dp[0] = 0;
        for coin in coins{
            let coin = coin as usize;
            for i in coin..=amount{
                // 避免下面i32::MAX+1溢出
                if dp[i - coin] != i32::MAX {
                    dp[i] = dp[i].min(dp[i - coin] + 1);
                }
                
            }
        }
        if dp[amount] != i32::MAX {
            dp[amount]
        } else {
            -1
        }
    }
}
```

运行结果
```
执行用时分布
5ms 击败78.64%

消耗内存分布
2.23MB 击败70.87%
```

欢迎来github上看更多题目的解答[力扣解题思路](https://github.com/WRAllen/LeetCode)
