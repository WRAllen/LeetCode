# é¢˜ç›®[239. æ»‘åŠ¨çª—å£æœ€å¤§å€¼](https://leetcode.cn/problems/sliding-window-maximum/description/?envType=study-plan-v2&envId=top-100-liked)

ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ numsï¼Œæœ‰ä¸€ä¸ªå¤§å°ä¸º k çš„æ»‘åŠ¨çª—å£ä»æ•°ç»„çš„æœ€å·¦ä¾§ç§»åŠ¨åˆ°æ•°ç»„çš„æœ€å³ä¾§ã€‚ä½ åªå¯ä»¥çœ‹åˆ°åœ¨æ»‘åŠ¨çª—å£å†…çš„ k ä¸ªæ•°å­—ã€‚æ»‘åŠ¨çª—å£æ¯æ¬¡åªå‘å³ç§»åŠ¨ä¸€ä½ã€‚

è¿”å› æ»‘åŠ¨çª—å£ä¸­çš„æœ€å¤§å€¼ ã€‚

ç¤ºä¾‹ 1ï¼š

    è¾“å…¥ï¼šnums = [1,3,-1,-3,5,3,6,7], k = 3
    è¾“å‡ºï¼š[3,3,5,5,6,7]
    è§£é‡Šï¼š
    æ»‘åŠ¨çª—å£çš„ä½ç½®                æœ€å¤§å€¼
    ---------------               -----
    [1  3  -1] -3  5  3  6  7       3
    1 [3  -1  -3] 5  3  6  7       3
    1  3 [-1  -3  5] 3  6  7       5
    1  3  -1 [-3  5  3] 6  7       5
    1  3  -1  -3 [5  3  6] 7       6
    1  3  -1  -3  5 [3  6  7]      7

ç¤ºä¾‹ 2ï¼š

    è¾“å…¥ï¼šnums = [1], k = 1
    è¾“å‡ºï¼š[1]
 

æç¤ºï¼š

    1 <= nums.length <= 105
    -10^4 <= nums[i] <= 10^4
    1 <= k <= nums.length

*****

# è§£é¢˜æ€è·¯

ç°åœ¨ä¼šå…ˆçœ‹çœ‹é¢˜ç›®çš„æç¤ºäº†ï¼Œé‡Œé¢å†™äº†æ¯ä¸ªå‚æ•°çš„èŒƒå›´ï¼Œä»¥å‰ä¸çŸ¥é“çœ‹ï¼Œå‡€çæƒ³ï¼Œå°±åˆšåˆšï¼Œæˆ‘è¿˜æƒ³kæ˜¯ä¸æ˜¯ä¼šç­‰äº0ğŸ¤ª

ç°åœ¨çœ‹æ¥ï¼Œå…ˆæ ¹æ®é¢˜ç›®çš„æ„æ€ï¼Œå†™ä¸€ä¸‹æš´åŠ›ç ´è§£

## â˜¹ï¸è§£æ³•1 æš´åŠ›ç ´è§£:

å°±æ˜¯ä¾æ®é¢˜ç›®çš„æ„æ€ï¼Œæ»‘åŠ¨çª—å£çš„æ€è·¯ï¼Œè¿™é‡Œæœ‰ä¸€ä¸ªå°ç‚¹ï¼Œç”±äºå·¦ä¸‹æ ‡ä¹Ÿåœ¨ç§»åŠ¨ï¼Œæ‰€ä»¥æœ‰å¯èƒ½å·¦ä¸‹æ ‡ç§»åŠ¨å‰ä»–æ­£å¥½æ˜¯è¿™kä¸ªæ•°å­—é‡Œé¢æœ€å¤§çš„å€¼

æ‰€ä»¥æš´åŠ›ç ´è§£å°±åœ¨å·¦ä¸‹æ ‡åˆ°å³ä¸‹æ ‡ç¡®å®šçš„æƒ…å†µä¸‹ï¼Œå†éå†ä¸€éï¼Œæ—¶é—´å¤æ‚åº¦ç›´æ¥O(n*m)äº†

### golangä»£ç 1

ä»£ç å¦‚ä¸‹

```go
func maxSlidingWindow(nums []int, k int) []int {
    result := make([]int, 0)
    for leftIndex := 0; leftIndex <= len(nums) - k; leftIndex ++ {
		tmpMax := nums[leftIndex]
		fmt.Println(leftIndex, leftIndex+ k)
		for i := leftIndex; i < leftIndex + k; i ++ {
			if nums[i] > tmpMax {
				tmpMax = nums[i]
			}
		}
		result = append(result, tmpMax)
    }
    return result
}

```

è¿è¡Œç»“æœ
```
è¶…å‡ºæ—¶é—´é™åˆ¶
41 / 51 ä¸ªé€šè¿‡çš„æµ‹è¯•ç”¨ä¾‹
```

è¿™é‡Œè¿™ä¸ªnumæ˜¯ä¸€ä¸ªè¶…çº§å¤§çš„æ•°ç»„(300kb+çš„ä¸€ä¸ªæ•°ç»„),ä¸€å…±64317ä¸ª

k = 32879


## â˜¹ï¸è§£æ³•2 å­—å…¸å­˜å‚¨æ»‘åŠ¨çª—å£å†…çš„ä¿¡æ¯:

ä¸Šé¢æš´åŠ›ç ´è§£åœ¨åšåˆ¤æ–­å¾ªç¯çš„æ—¶å€™ï¼Œå…¶å®åšäº†å¾ˆå¤šæ— ç”¨å·¥ï¼Œå› ä¸ºå˜åŠ¨çš„åªæœ‰å¼€å§‹å’Œç»“æŸçš„2ä½ï¼Œå¯æ˜¯æ¯æ¬¡å´å¾ªç¯äº†kä¸ªæ•°å­—

é—®é¢˜å°±å˜æˆäº† leftIndex ï½ rightIndex è¿™äº›å­èŒƒå›´å†…çš„æœ€å¤§å€¼æ€ä¹ˆåˆ¤æ–­

å…¶å®leftIndexç§»åŠ¨çš„æ—¶å€™ï¼Œæœ‰2ç§æƒ…å†µ

1.leftIndexç§»åŠ¨å‰è¿™ä¸ªä½ç½®çš„æ•°ä¸æ˜¯æœ€å¤§çš„ï¼Œè¿™é‡Œå°±ä¸ä¼šå½±å“åˆ°ç»“æœ

2.leftIndexç§»åŠ¨å‰è¿™ä¸ªä½ç½®çš„æ•°æ˜¯æœ€å¤§çš„

2.1 å½“å‰æœ€å¤§å€¼åœ¨èŒƒå›´å†…åªæœ‰1ä¸ªï¼Œé‚£å°±éœ€è¦æ‰¾å‡ºç¬¬äºŒå¤§

2.2 å½“å‰æœ€å¤§å€¼åœ¨èŒƒå›´å†…æœ‰å¤šä¸ªï¼Œé‚£å°±ä¸å½±å“ç»“æœ

é‚£ä¹ˆå°±éœ€è¦æœ‰åœ°æ–¹èƒ½è®°å½•è¿™äº›å€¼ï¼Œå¹¶ä¸”ä¸æ˜¯ç®€å•çš„è®°å½•ä¸€ä¸‹æœ€å¤§å€¼çš„ä½ç½®ï¼Œ

é‚£å‡è®¾å¦‚æœåªè®°å½•æœ€å¤§å€¼å’Œç¬¬äºŒå¤§å€¼æ˜¯å¦å¯è¡Œå‘¢ï¼Œ

    æ‹¿ä¾‹å­æ•°æ®æ¥ä¸¾ä¾‹
    1,3,-1,-3,5,3,6,7

    1 3 -1 æ—¶ æœ€å¤§3 ç¬¬äºŒå¤§1

    3 -1 -3 è¿™ä¸ªæ—¶å€™ç¬¬äºŒå¤§æ²¡äº†ï¼Œå¹¶ä¸”è¿›æ¥çš„-3æ¯”ä¹‹å‰çš„-1è¿˜è¦å°ï¼Œä½†æ˜¯ç”±äº-1æ²¡è®°å½•ï¼Œæ‰€ä»¥æ•°æ®å°±ä¸¢å¤±äº†
    æ²¡æ³•ç»´æŠ¤3æœ€å¤§ï¼Œ-1ç¬¬äºŒå¤§çš„æƒ…å†µ

æ‰€ä»¥è¿™æ ·ç®€å•çš„è®°å½•æœ€å¤§å€¼å’Œç¬¬äºŒå¤§å€¼æ˜¯ä¸è¡Œçš„ï¼Œéœ€è¦æœ‰ä¸ªæ•°æ®èƒ½ç»´æŠ¤æ»‘åŠ¨çª—å£å†…çš„å€¼çš„æƒ…å†µ

é‚£å¦‚æœæˆ‘ç”¨ä¸€ä¸ªå­—å…¸æŠŠæ»‘åŠ¨çª—å£å†…çš„å€¼å’Œæ•°é‡ç»´æŠ¤èµ·æ¥ï¼Œkeyæ˜¯å½“å‰nums[i]çš„å€¼ï¼Œvaluesæ˜¯å‡ºç°çš„æ¬¡æ•°

å·¦è¾¹å‡ºå»ä¸€ä¸ªï¼Œå°±æŠŠkeyå¯¹åº”çš„values-1ï¼Œå³è¾¹è¿›æ¥ä¸€ä¸ªå°±æŠŠå¯¹åº”çš„values+1

è¿™æ ·å¯ä»¥ç»´æŠ¤çª—å£å†…çš„æ•°æ®æƒ…å†µï¼Œä½†æ˜¯é—®é¢˜åˆæ¥äº†ï¼Œæ¯æ¬¡æ»‘åŠ¨çš„æ˜¯æ—¶å€™éœ€è¦èƒ½çŸ¥é“å½“å‰è¿™ä¸ªå­—å…¸é‡Œé¢çš„æœ€å¤§keyæ˜¯å•¥

è¿™é‡Œå¦‚æœé€šè¿‡éå†æ‰€æœ‰keyå»å–å€¼çš„è¯ï¼Œç†è®ºä¸Šå’Œä¸Šé¢çš„æš´åŠ›ç ´è§£åœ¨æŸäº›ç‰¹æ®Šcaseä¸Šå¤æ‚åº¦åº”è¯¥æ˜¯å·®ä¸å¤šçš„ï¼Œè¿™é‡Œå°±å˜æˆéœ€è¦çŸ¥é“æœ€å¤§çš„keyæ˜¯å•¥
ä½†æ˜¯è¿™æœ‰ç‚¹æœ¬æœ«å€’ç½®äº†ï¼Œæˆ‘è¦æ˜¯çŸ¥é“æœ€å¤§çš„keyæ˜¯å•¥ï¼Œæˆ‘è¿˜ç”¨å•¥å­—å…¸æ¥å­˜å‚¨å¤šä½™çš„æ•°æ®

ä¸Šé¢è¿™ç§æƒ…å†µåº”è¯¥é€‚ç”¨äºnums[i]çš„å–å€¼èŒƒå›´ç›¸å¯¹è¾ƒå°çš„caseï¼Œè¿™æ ·çŸ¥é“èŒƒå›´ï¼Œå¯ä»¥ä»å¤§åˆ°å°éå†å­—å…¸ï¼Œ
å‘ç°values>0å°±è¯´æ˜æ‰¾åˆ°æœ€å¤§å€¼äº†

ä½†æ˜¯é¢˜ç›®çš„nums[i]èŒƒå›´å¤ªå¤§äº†ï¼Œæœ¬é¢˜ä¸é€‚åˆç”¨è¿™ç§æ–¹å¼


## è§£æ³•3 æœ€å¤§å †

å½“æ•°ç»„å’Œå­—å…¸è§£å†³ä¸äº†é—®é¢˜çš„æ—¶å€™ï¼Œå°±è¦æ€è€ƒæœ‰æ²¡æœ‰å…¶ä»–æ•°æ®ç»“æ„èƒ½è§£å†³è¿™ä¸ªé—®é¢˜äº†

ä¹‹å‰æœ‰è€ƒè™‘è¿‡å †ï¼Œä½†æ˜¯å¯¹è¿™ä¸ªæ•°æ®ç»“æ„ä¸å¤ªæ¸…æ™°ï¼Œå°±æ²¡å¾€è¿™æ–¹é¢è€ƒè™‘ï¼ˆçœ‹äº†å®˜æ–¹é¢˜è§£ï¼ŒçŸ¥é“ç”¨æœ€å¤§å †ï¼‰

ä¸‹é¢æ¥å¤ä¹ ä¸€ä¸‹ï¼Œæœ€å¤§å †ï¼ˆMax Heapï¼‰

æœ€å¤§å †æ˜¯ä¸€ç§å®Œå…¨äºŒå‰æ ‘ï¼Œå¹¶ä¸”æ»¡è¶³æ¯ä¸ªèŠ‚ç‚¹çš„å€¼éƒ½å¤§äºæˆ–è€…ç­‰äºå…¶å­èŠ‚ç‚¹çš„å€¼

è¿™æ ·æ»‘åŠ¨çš„æ—¶å€™ï¼Œæ¯æ¬¡å–rootçš„å€¼ï¼Œå°±å¯ä»¥è·å–åˆ°ç»“æœäº†ï¼Œé‚£æœ€å¤§å †æ˜¯å¦‚ä½•åšåˆ°è§£æ³•2é‡Œé¢mapåšä¸åˆ°çš„äº‹æƒ…å‘¢

golangé‡Œé¢ç”¨ä¸€ä¸ªlistç»´æŠ¤äº†è¿™ä¸ªå †ï¼Œè¿™ä¸ªlistçš„é¡ºåºï¼Œä»£è¡¨äº†ä»rootï¼Œç„¶åä¾æ¬¡å‘ä¸‹ï¼Œä»å·¦åˆ°å³ï¼Œåˆ°æœ€åº•å±‚

æ¯”å¦‚ä¸€ä¸ªå¦‚ä¸‹çš„å †ï¼ˆå·¦è¾¹èŠ‚ç‚¹ä¸ç”¨ä¸€å®šæ¯”å³è¾¹èŠ‚ç‚¹å¤§ï¼‰:

           50
          /  \
        30    40
        / \    / \
       10 20  35 25      


åœ¨golangå­˜å‚¨æ˜¯è¿™æ ·çš„:

    {50, 30, 40, 10, 20, 35, 25}

ç¬¬[0]ä½æ˜¯æœ€å¤§å€¼

è¿™é‡Œå°±æœ‰å‡ ä¸ªå®šç†å¦‚æœå½“å‰çš„ä¸‹æ ‡æ˜¯iï¼Œé‚£ä¹ˆ

ä»–çš„çˆ¶èŠ‚ç‚¹çš„åæ ‡=(i-1)/2(æ•´é™¤2ï¼Œå¹¶ä¸”i>0)

å·¦å­èŠ‚ç‚¹=i*2+1

å³å­èŠ‚ç‚¹=i*2+2


ä¸‹é¢ç”¨golangå®ç°ä¸€ä¸‹æœ€å¤§å †
```go
package main

import "fmt"

type MaxHeap struct {
	data []int
}

// æ’å…¥å…ƒç´ ,æŠŠå…ƒç´ æ·»åŠ åˆ°å°¾éƒ¨ï¼Œæ‰§è¡Œä¸Šæµ®æ“ä½œ
func (h *MaxHeap) Push(x int) {
	h.data = append(h.data, x)
	h.up(len(h.data) - 1)
}

// å¼¹å‡ºæœ€å¤§å…ƒç´ ï¼Œ æŠŠå°¾å·´å…ƒç´ æ›¿æ¢å½“å‰çš„å †é¡¶ï¼Œæ‰§è¡Œä¸‹æµ®æ“ä½œ
func (h *MaxHeap) Pop() int {
	if len(h.data) == 0 {
		panic("heap is empty")
	}
	max := h.data[0]
	last := h.data[len(h.data)-1]
	h.data = h.data[:len(h.data)-1]
	if len(h.data) > 0 {
		h.data[0] = last
		h.down(0)
	}
	return max
}

// è·å–å †é¡¶
func (h *MaxHeap) Peek() int {
	if len(h.data) == 0 {
		panic("heap is empty")
	}
	return h.data[0]
}

// ä¸Šæµ®æ“ä½œ æ¯”è¾ƒå½“å‰çˆ¶èŠ‚ç‚¹çš„å€¼ï¼Œå¦‚æœæ¯”çˆ¶èŠ‚ç‚¹å¤§ï¼Œå°±æ›¿æ¢çˆ¶èŠ‚ç‚¹
func (h *MaxHeap) up(index int) {
	for index > 0 {
		parent := (index - 1) / 2
		if h.data[parent] >= h.data[index] {
			break
		}
		h.data[parent], h.data[index] = h.data[index], h.data[parent]
		index = parent
	}
}

// ä¸‹æ²‰æ“ä½œ
func (h *MaxHeap) down(index int) {
	n := len(h.data)
	for {
		left := 2*index + 1
		right := 2*index + 2
		largest := index

		if left < n && h.data[left] > h.data[largest] {
			largest = left
		}
		if right < n && h.data[right] > h.data[largest] {
			largest = right
		}
        // å¦‚æœå½“å‰çš„indexå°±æ˜¯æœ€å¤§çš„ï¼Œç»“æŸä¸‹æ²‰æ¾³æ´²
		if largest == index {
			break
		}
        // æŠŠå½“å‰ä¸‹æ ‡æ‰€åœ¨çš„å’Œæœ€å¤§çš„å­èŠ‚ç‚¹è°ƒæ¢ä½ç½®
		h.data[index], h.data[largest] = h.data[largest], h.data[index]
        // æŠŠå½“å‰åæ ‡è®¾ç½®æˆä¹‹å‰çš„å­èŠ‚ç‚¹åæ ‡ï¼Œç„¶åé€’å½’ï¼Œå†æ¬¡åšä¸‹æ²‰æ“ä½œ
		index = largest
	}
}

func main() {
	h := &MaxHeap{}
	h.Push(3)
	h.Push(10)
	h.Push(5)
	h.Push(1)

	fmt.Println("å †é¡¶:", h.Peek()) // 10

	for len(h.data) > 0 {
		fmt.Println(h.Pop()) // è¾“å‡ºé¡ºåº: 10, 5, 3, 1
	}
}
```

æœ‰äº†ä¸Šé¢çš„æœ€å¤§å †ï¼Œé‚£è¿˜æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œæ€ä¹ˆæŠŠæœ€å·¦è¾¹è¿™ä¸ªå…ƒç´ ä»æœ€å¤§å †é‡Œé¢popå‡ºå»å‘¢ï¼Œè¿™é‡Œå¯ä»¥æ‹“å±•ä¸€ä¸‹æœ€å¤§å †å­˜å‚¨çš„æ•°æ®

å¯ä»¥æŠŠå †é‡Œé¢å­˜å‚¨ä¸€ä¸ªç»“æ„ä½“ï¼Œè¿™ä¸ªç»“æ„ä½“ï¼Œé‡Œé¢æœ‰ä¸€ä¸ªvalueå€¼ï¼Œå’Œä¸€ä¸ªå½“å‰valueså€¼çš„ä¸‹æ ‡

åœ¨çª—å£æ»‘åŠ¨çš„æ—¶å€™ï¼Œå¦‚æœå½“å‰æœ€å¤§å †çš„rootï¼Œåœ¨ä¸‹æ ‡ä¸åœ¨å½“å‰çš„æ»‘åŠ¨çª—å£é‡Œé¢ï¼Œé‚£å°±å¯ä»¥ä¸€ç›´popï¼ŒçŸ¥é“ä¸‹æ ‡åœ¨çª—å£é‡Œé¢

è¿™æ ·å½“å‰rootçš„valueså°±æ˜¯å½“å‰æœ€å¤§çš„å€¼ï¼Œæ‰€ä»¥ä¿®æ”¹ä¸€ä¸‹å¦‚ä¸Šä»£ç å¦‚ä¸‹


```go
package main

import "fmt"


type Item struct {
	value int
	index int
}

type MaxHeap struct {
	data []Item
}

// æ’å…¥å…ƒç´ ,æŠŠå…ƒç´ æ·»åŠ åˆ°å°¾éƒ¨ï¼Œæ‰§è¡Œä¸Šæµ®æ“ä½œ
func (h *MaxHeap) Push(each Item) {
	h.data = append(h.data, each)
	h.up(len(h.data) - 1)
}

// å¼¹å‡ºæœ€å¤§å…ƒç´ ï¼Œ æŠŠå°¾å·´å…ƒç´ æ›¿æ¢å½“å‰çš„å †é¡¶ï¼Œæ‰§è¡Œä¸‹æµ®æ“ä½œ
func (h *MaxHeap) Pop() Item {
	if len(h.data) == 0 {
		panic("heap is empty")
	}
	max := h.data[0]
	last := h.data[len(h.data)-1]
	h.data = h.data[:len(h.data)-1]
	if len(h.data) > 0 {
		h.data[0] = last
		h.down(0)
	}
	return max
}

// è·å–å †é¡¶
func (h *MaxHeap) Peek() Item {
	if len(h.data) == 0 {
		panic("heap is empty")
	}
	return h.data[0]
}

// ä¸Šæµ®æ“ä½œ æ¯”è¾ƒå½“å‰çˆ¶èŠ‚ç‚¹çš„å€¼ï¼Œå¦‚æœæ¯”çˆ¶èŠ‚ç‚¹å¤§ï¼Œå°±æ›¿æ¢çˆ¶èŠ‚ç‚¹
func (h *MaxHeap) up(index int) {
	for index > 0 {
		parent := (index - 1) / 2
		if h.data[parent].value >= h.data[index].value {
			break
		}
		h.data[parent], h.data[index] = h.data[index], h.data[parent]
		index = parent
	}
}

// ä¸‹æ²‰æ“ä½œ
func (h *MaxHeap) down(index int) {
	n := len(h.data)
	for {
		left := 2*index + 1
		right := 2*index + 2
		largest := index

		if left < n && h.data[left].value > h.data[largest].value {
			largest = left
		}
		if right < n && h.data[right].value > h.data[largest].value {
			largest = right
		}
        // å¦‚æœå½“å‰çš„indexå°±æ˜¯æœ€å¤§çš„ï¼Œç»“æŸä¸‹æ²‰æ¾³æ´²
		if largest == index {
			break
		}
        // æŠŠå½“å‰ä¸‹æ ‡æ‰€åœ¨çš„å’Œæœ€å¤§çš„å­èŠ‚ç‚¹è°ƒæ¢ä½ç½®
		h.data[index], h.data[largest] = h.data[largest], h.data[index]
        // æŠŠå½“å‰åæ ‡è®¾ç½®æˆä¹‹å‰çš„å­èŠ‚ç‚¹åæ ‡ï¼Œç„¶åé€’å½’ï¼Œå†æ¬¡åšä¸‹æ²‰æ“ä½œ
		index = largest
	}
}


func main() {
	h := &MaxHeap{}
	h.Push(Item{value: 3, index: 0})
	h.Push(Item{value: 10, index: 1})
	h.Push(Item{value: 5, index: 2})
	h.Push(Item{value: 1, index: 3})

	fmt.Println("å †é¡¶:", h.Peek())

	for len(h.data) > 0 {
		fmt.Println(h.Pop())
	}
}
```

æµ‹è¯•æ²¡é—®é¢˜äº†ï¼Œå¼€å§‹ç»“åˆé¢˜ç›®ï¼Œå…ˆåˆå§‹åŒ–è¿™ä¸ªæœ€å¤§å †ï¼Œç„¶åå¼€å§‹æ»‘åŠ¨ï¼Œæ»‘åŠ¨çš„æ—¶å€™å…ˆæŠŠä¸‹æ ‡çš„ä¿¡æ¯appendåˆ°å †é‡Œé¢

ç„¶åå¼€å§‹åˆ¤æ–­å½“å‰å †çš„rootæ˜¯å¦åœ¨æ»‘åŠ¨çª—å£é‡Œé¢ï¼Œä¸åœ¨å°±è¿›è¡Œpopæ“ä½œï¼ŒçŸ¥é“åœ¨æ»‘åŠ¨çª—å£é‡Œé¢ï¼Œé‚£è¿™ä¸ªæ—¶å€™çš„rootå°±æ˜¯æœ€å¤§çš„å€¼

æŠŠrootçš„å€¼è¿½åŠ åˆ°ç»“æœé‡Œé¢ï¼Œæœ€åè¿”å›ç»“æœå³å¯




### golangä»£ç 1
```go
package main

import "fmt"


type Item struct {
	value int
	index int
}

type MaxHeap struct {
	data []Item
}

// æ’å…¥å…ƒç´ ,æŠŠå…ƒç´ æ·»åŠ åˆ°å°¾éƒ¨ï¼Œæ‰§è¡Œä¸Šæµ®æ“ä½œ
func (h *MaxHeap) Push(each Item) {
	h.data = append(h.data, each)
	h.up(len(h.data) - 1)
}

// å¼¹å‡ºæœ€å¤§å…ƒç´ ï¼Œ æŠŠå°¾å·´å…ƒç´ æ›¿æ¢å½“å‰çš„å †é¡¶ï¼Œæ‰§è¡Œä¸‹æµ®æ“ä½œ
func (h *MaxHeap) Pop() Item {
	if len(h.data) == 0 {
		panic("heap is empty")
	}
	max := h.data[0]
	last := h.data[len(h.data)-1]
	h.data = h.data[:len(h.data)-1]
	if len(h.data) > 0 {
		h.data[0] = last
		h.down(0)
	}
	return max
}

// è·å–å †é¡¶
func (h *MaxHeap) Peek() Item {
	if len(h.data) == 0 {
		panic("heap is empty")
	}
	return h.data[0]
}

// ä¸Šæµ®æ“ä½œ æ¯”è¾ƒå½“å‰çˆ¶èŠ‚ç‚¹çš„å€¼ï¼Œå¦‚æœæ¯”çˆ¶èŠ‚ç‚¹å¤§ï¼Œå°±æ›¿æ¢çˆ¶èŠ‚ç‚¹
func (h *MaxHeap) up(index int) {
	for index > 0 {
		parent := (index - 1) / 2
		if h.data[parent].value >= h.data[index].value {
			break
		}
		h.data[parent], h.data[index] = h.data[index], h.data[parent]
		index = parent
	}
}

// ä¸‹æ²‰æ“ä½œ
func (h *MaxHeap) down(index int) {
	n := len(h.data)
	for {
		left := 2*index + 1
		right := 2*index + 2
		largest := index

		if left < n && h.data[left].value > h.data[largest].value {
			largest = left
		}
		if right < n && h.data[right].value > h.data[largest].value {
			largest = right
		}
        // å¦‚æœå½“å‰çš„indexå°±æ˜¯æœ€å¤§çš„ï¼Œç»“æŸä¸‹æ²‰æ¾³æ´²
		if largest == index {
			break
		}
        // æŠŠå½“å‰ä¸‹æ ‡æ‰€åœ¨çš„å’Œæœ€å¤§çš„å­èŠ‚ç‚¹è°ƒæ¢ä½ç½®
		h.data[index], h.data[largest] = h.data[largest], h.data[index]
        // æŠŠå½“å‰åæ ‡è®¾ç½®æˆä¹‹å‰çš„å­èŠ‚ç‚¹åæ ‡ï¼Œç„¶åé€’å½’ï¼Œå†æ¬¡åšä¸‹æ²‰æ“ä½œ
		index = largest
	}
}

func maxSlidingWindow(nums []int, k int) []int {
    result := make([]int, 0)
    maxHeap := &MaxHeap{}
	for i := 0; i < k; i++ {
		maxHeap.Push(Item{
			value: nums[i],
			index: i,
		})
	}
	result = append(result, maxHeap.Peek().value)
	// å¼€å§‹æ»‘åŠ¨
	for i := k; i < len(nums); i++ {
		maxHeap.Push(Item{
			value: nums[i],
			index: i,
		})
		for {
			root := maxHeap.Peek()
			// å½“å‰rootèŠ‚ç‚¹çš„ä¸‹æ ‡å¦‚æœåœ¨æ»‘åŠ¨çª—å£çš„å·¦è¾¹ï¼Œå°±è¯´æ˜å½“å‰rootä¸åœ¨æ»‘åŠ¨çª—å£é‡Œé¢ï¼Œéœ€è¦å¼¹å‡º
			if root.index <= i - k {
				maxHeap.Pop()
			} else {
                // è¯´æ˜rootåœ¨æ»‘åŠ¨çª—å£é‡Œé¢äº†
                break
            }
			
		}
		root := maxHeap.Peek()
		result = append(result, root.value)		
	}

    return result
}
```

è¿è¡Œç»“æœ
```
æ‰§è¡Œç”¨æ—¶åˆ†å¸ƒ
39ms å‡»è´¥15.52%

æ¶ˆè€—å†…å­˜åˆ†å¸ƒ
11.50MB å‡»è´¥6.81%
```

### golangä»£ç 2

å…¶å®è¿™é‡Œæœ€å¤§å †åªè¦è®°å½•ä¸‹æ ‡å°±è¡Œï¼Œå› ä¸ºé€šè¿‡ä¸‹æ ‡ç»“åˆä¼ å…¥çš„numsåˆ—è¡¨ï¼Œä¹Ÿèƒ½çŸ¥é“å€¼ï¼Œä¸‹é¢ç›´æ¥ç”¨golangè‡ªå¸¦çš„å †æ¥ç®€åŒ–è§£é¢˜ï¼ˆæ¯•ç«Ÿé¢è¯•çš„æ—¶å€™è¦å†™ä¸ªæœ€å¤§å †ä¹Ÿæ˜¯è´¹å¿ƒè´¹åŠ›ï¼‰


golangçš„æœ€å¤§å †ï¼ˆå®˜æ–¹æ²¡æœ‰æä¾›å…·ä½“ç»“æ„ï¼Œæä¾›äº†é€šç”¨çš„heapæ¥å£æœºåˆ¶ï¼‰
```go
import (
	"sort"
	"container/heap"
)
type Interface interface {
    sort.Interface  // åŒ…å« Len(), Less(i, j int), Swap(i, j int)
    Push(x any)     // æ·»åŠ å…ƒç´ 
    Pop() any       // ç§»é™¤å¹¶è¿”å›æœ€åä¸€ä¸ªå…ƒç´ 
}
```
ç”¨æˆ·éœ€è¦å»ç»§æ‰¿å®ç°æœ€å¤§å †/æœ€å°å †

```go
package main

import (
	// ä¸‹é¢ä½¿ç”¨heap.Initæ—¶ä½¿ç”¨åˆ°
	"container/heap"
	"sort"
)

type MaxHeap struct {
	// IntSliceé‡Œé¢æœ‰Len(), Less(), Swap()
	sort.IntSlice 
}

// è¿™é‡Œé»˜è®¤æ—¶æœ€å°å †ï¼Œéœ€è¦é‡å†™ä¸€ä¸‹ï¼Œæœ¬æ¥æ˜¯
// func (x IntSlice) Less(i, j int) bool { return x[i] < x[j] }
func (h *MaxHeap) Less(i, j int) bool {
	return h.IntSlice[i] > h.IntSlice[j]
}

func (h *MaxHeap) Push(each any) {
	h.IntSlice = append(h.IntSlice, each.(int))
}

func (h *MaxHeap) Pop() any {
	last := h.IntSlice[len(h.IntSlice)-1]
	h.IntSlice = h.IntSlice[:len(h.IntSlice)-1]
	return last
}

func main() {
	h := &MaxHeap{make([]int, 0)}
	h.IntSlice = []int{3, 1, 5, 2, 4}
    heap.Init(h)
    heap.Push(h, 6)
    fmt.Println(heap.Pop(h)) // è¾“å‡º 6ï¼ˆæœ€å¤§å€¼ï¼‰
    fmt.Println(heap.Pop(h)) // è¾“å‡º 5
}

```

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬è¦å†æ¬¡æ”¹å†™ä¸€ä¸‹lesså‡½æ•°ï¼Œå› ä¸ºä¸Šé¢ä¸‹æ ‡ç›´æ¥ä»£è¡¨å¯¹åº”çš„å€¼ï¼Œå¯æ˜¯æˆ‘ä»¬çš„ä¸æ˜¯ï¼Œæˆ‘ä»¬å®é™…å­˜å‚¨äº†ä¸‹æ ‡ï¼Œå¹¶ä¸æ˜¯å€¼ï¼Œæ‰€ä»¥è¿˜éœ€è¦ç”¨ä¸Šnumsï¼Œå®Œæ•´ä»£ç å¦‚ä¸‹
```go
var originNum []int

type MaxHeap struct {
    sort.IntSlice
}

func(h *MaxHeap) Less(i, j int) bool {
    return originNum[h.IntSlice[i]] > originNum[h.IntSlice[j]]
}

func(h *MaxHeap) Push(each any) {
    h.IntSlice = append(h.IntSlice, each.(int))
}

func(h *MaxHeap) Pop () any {
    last := h.IntSlice[h.Len()-1]
    h.IntSlice = h.IntSlice[:h.Len()-1]
    return last
}

func(h *MaxHeap) Peek() int {
    return h.IntSlice[0]
}

func(h *MaxHeap) PeekValue() int {
    return originNum[h.Peek()]
}

func maxSlidingWindow(nums []int, k int) []int {
    result := make([]int, 0)
    originNum = nums
    maxHeap := &MaxHeap{make([]int, k)}
    for i := 0; i < k; i ++ {
        maxHeap.IntSlice[i] = i
    }
	// æœ€ç»ˆå †çš„æ“ä½œéƒ½éœ€è¦ä¾èµ–heapè¿™ä¸ªåŒ…
	heap.Init(maxHeap)
    result = append(result, maxHeap.PeekValue())
    for i := k; i < len(nums); i ++ {
		heap.Push(maxHeap, i)
		// å½“å‰åæ ‡å¾€å‰ï¼ˆå‘å·¦ï¼‰ç§»åŠ¨kä½
		for maxHeap.Peek() <= i - k {
			heap.Pop(maxHeap)
		}
		result = append(result, maxHeap.PeekValue())

	}
    return result
}
```

è¿è¡Œç»“æœ
```
æ‰§è¡Œç”¨æ—¶åˆ†å¸ƒ
83ms å‡»è´¥11.18%

æ¶ˆè€—å†…å­˜åˆ†å¸ƒ
10.37MB å‡»è´¥34.95%
```


## è§£æ³•4 å•è°ƒåˆ—è¡¨


### pythonä»£ç 1

ç”±äºpythonçš„heapqæ˜¯å·²ç»å°è£…å¥½çš„æœ€å°å †ï¼Œå¦‚æœè¦æœ€å¤§å †ï¼Œåªéœ€pushè¿›å»çš„valuesè®¾ç½®æˆè´Ÿæ•°å³å¯å®ç°æœ€å¤§å †

ä½†æ˜¯ç”±äºè¿™é¢˜éœ€è¦æŠŠä¸‹æ ‡å­˜å…¥å †ï¼Œéœ€è¦èƒ½åƒgolangé‚£æ ·ä¿®æ”¹æ¯”è¾ƒå‡½æ•°æ¯”è¾ƒéº»çƒ¦ï¼Œæœ‰ç‚¹ä¸ºäº†é†‹åŒ…é¥ºå­çš„åšæ³•äº†

æœ¬è´¨ä¸Šå°±æ˜¯éœ€è¦ä¸€ä¸ªlistç”¨æ¥å•è°ƒå­˜å‚¨ä¸‹æ ‡ï¼ˆæ ¹æ®ä¸‹æ ‡çš„å€¼ï¼‰ï¼Œæ‰€ä»¥æˆ‘ä»¬è‡ªå·±ç»´æŠ¤ä¸€ä¸ªå°±è¡Œ


```python
class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        result = []
        # æ ¹æ®valuesçš„å€¼ï¼Œå•è°ƒé€’å¢çš„åˆ—è¡¨ï¼Œé‡Œé¢çš„valuesä¸ºnumså¯¹åº”çš„ä¸‹æ ‡
        max_heap = []
        for i, v in enumerate(nums):
            # å¦‚æœå½“å‰çš„å€¼æ¯”max_heapçš„æœ€å¤§å€¼,å°±æŠŠæ¯”ä»–å°çš„éƒ½popå‡ºå»ï¼Œä¿è¯max_heapæ˜¯å•è°ƒé€’å‡çš„
            # ä¾‹å¦‚ã€3ï¼Œ -1ï¼Œ -3ã€‘
            while max_heap and nums[max_heap[-1]] < v:
                max_heap.pop()
            # å¦‚æœå½“å‰max_heapçš„ç¬¬ä¸€ä½ï¼Œä¹Ÿå°±æ˜¯æœ€å¤§çš„é‚£ä½ï¼Œçš„ä¸‹æ ‡ä¸åœ¨å½“å‰çš„æ»‘åŠ¨çª—å£å†…
            # å°±æŠŠå®ƒåˆ é™¤äº†ï¼Œå› ä¸ºä»–æ˜¯æ— ç”¨çš„æ•°æ®
            while max_heap and max_heap[0] <= i - k:
                max_heap = max_heap[1:]
            # ä¸Šè¿°å¤„ç†åï¼Œmax_heapå°±æ˜¯ç¬¦åˆæ¡ä»¶çš„ï¼Œç›´æ¥append
            max_heap.append(i)
            # ä¸‹æ ‡ä»k-1å¼€å§‹ï¼Œæ¯æ¬¡ç§»åŠ¨ä¸€ä½ï¼Œå°±è¦æŠŠæœ€å¤§å€¼æ”¾å…¥ç»“æœå†…
            if i >= k - 1:
                result.append(nums[max_heap[0]])
        return result
```

è¿è¡Œç»“æœ
```
æ‰§è¡Œç”¨æ—¶åˆ†å¸ƒ
6825ms å‡»è´¥5.04%

æ¶ˆè€—å†…å­˜åˆ†å¸ƒ
30.20MB å‡»è´¥93.37%
```


### golangä»£ç 1

ç»™äºˆpythonçš„æ€è·¯ï¼Œæˆ‘ä»¬æŠŠgolangçš„ä¹Ÿå†™ä¸€ä¸‹

```go
func maxSlidingWindow(nums []int, k int) []int {
    result := make([]int, 0)
    maxHeap := make([]int, 0)
    for i := 0; i < len(nums); i ++ {
        for len(maxHeap) > 0 && nums[maxHeap[len(maxHeap)-1]] < nums[i]{
            maxHeap = maxHeap[:len(maxHeap)-1]
        }
        for len(maxHeap) > 0 && maxHeap[0] <= i - k{
            maxHeap = maxHeap[1:]
        }
        maxHeap = append(maxHeap, i)
        if i >= k - 1 {
            result = append(result, nums[maxHeap[0]])
        }
    }
    return result
}
```


æ‰§è¡Œç»“æœ
```
æ‰§è¡Œç”¨æ—¶åˆ†å¸ƒ
5ms å‡»è´¥86.34%

æ¶ˆè€—å†…å­˜åˆ†å¸ƒ
9.82MB å‡»è´¥93.79%
```

å‘ç°æ•ˆæœæ¯”ä¹‹å‰çš„goä»£ç éƒ½è¦å¥½ğŸ˜„ï¼Œåæ€ä¸€ä¸‹ï¼Œå…¶å®ç”¨å †æœ‰ç‚¹å¤æ‚äº†ï¼Œè™½ç„¶ä¹Ÿæ˜¯åˆ—è¡¨ï¼Œä½†æ˜¯å¤šäº†å¾ˆå¤šupå’Œdownçš„æ“ä½œ

æœ¬è´¨ä¸Šåªæ˜¯éœ€è¦ä¸€ä¸ªä»å¤§åˆ°å°çš„é˜Ÿåˆ—ï¼Œå¯ä»¥ç”¨æ¥åˆ¤æ–­å°±è¡Œï¼Œæˆ‘è®¤ä¸ºæ–¹æ³•4æ˜¯æ¯”ä¹‹å‰çš„æ–¹æ³•éƒ½è¦å¥½çš„ï¼Œä¸ç®¡æ˜¯æ—¶é—´è¿˜æ˜¯ç©ºé—´ä¸Šï¼ˆæ‰§è¡Œç»“æœä¹Ÿè¯´æ˜äº†ä¸€åˆ‡ï¼‰

ä½†æ˜¯æ–¹æ³•4ï¼Œæœ‰ä¸ªå¾ˆtrickçš„åœ°æ–¹ï¼Œå°±æ˜¯å•è°ƒé€’å‡é˜Ÿåˆ—æ€ä¹ˆç»´æŠ¤ï¼Œä¹‹å‰ç”¨æœ€å¤§å †å°±æ˜¯å› ä¸ºä»–å¸®æˆ‘ä»¬åšäº†è¿™ä¸ªäº‹æƒ…ï¼Œä½†æ˜¯å…¶å®å‘ç°ç”¨ä¸‹é¢çš„ä»£ç (è¿™é‡Œç”¨pythonæ¯”è¾ƒå¥½çœ‹ä¸€ç‚¹)
```python
while max_heap and nums[max_heap[-1]] < v:
	max_heap.pop()
# å¿½ç•¥å…¶ä»–ä»£ç 
max_headp.append(i)
```
å°±èƒ½å®ç°è¿™ä¸ªå•è°ƒé€’å‡é˜Ÿåˆ—ï¼Œè€Œä¸”è¿™ä¸ªä¹Ÿä¸ç”¨å½“å¿ƒä¼šä¸¢å¤±ç¬¬äºŒå¤§çš„å€¼ï¼Œæˆ–è€…æ˜¯ç¬¬ä¸‰å¤§çš„å€¼ï¼Œå› ä¸ºè¿™äº›å€¼éƒ½ä¼šappendåœ¨å½“å‰çš„æœ€å¤§å€¼ä¸Š

è¿™é‡Œåšä¸ªæ¼”ç¤ºï¼Œæˆ‘ä»¬ç®€å•ç‚¹ä¹Ÿä¸å­˜å‚¨ä¸‹æ ‡äº†ï¼Œç›´æ¥å­˜å‚¨å€¼ï¼Œä¹Ÿä¸è€ƒè™‘æ»‘åŠ¨çª—å£äº†ï¼Œç›´æ¥æ¨æ¼”ä¸€ä¸‹ä¸ºå•¥ä»–å¯ä»¥ç»´æŠ¤ä¸€ä¸ªé€’å‡åˆ—è¡¨

å¯¹äºæµ‹è¯•ç”¨ä¾‹[1,3,-1,-3,5,3,6,7]æ¥è¯´

```
ç”±äºåˆšåˆšå¼€å§‹max_heapä¸ºç©ºï¼Œæ‰€ä»¥ç›´æ¥append
max_headp = [1]

é‡åˆ°3ï¼Œç”±äº3æ¯”1å¤§ï¼Œæ‰€ä»¥popæ‰max_headpæœ€åä¸€ä½ï¼Œç„¶åmax_headpä¸ºç©ºï¼Œç›´æ¥append
max_headp = [3]

é‡åˆ°-1ï¼Œç”±äº-1æ¯”3å°ï¼Œæ‰€ä»¥ç›´æ¥append
max_headp = [3, -1]

é‡åˆ°1ï¼Œç”±äº1æ¯”-1å¤§ï¼Œæ‰€ä»¥è¿›è¡Œpopï¼Œä½†æ˜¯popåå‘ç°1ä¸ä¼šæ¯”3å¤§ï¼Œæ‰€ä»¥append
max_headp = [3ï¼Œ 1]
```

çœ‹åˆ°è¿™é‡Œå°±çŸ¥é“ä¸ºå•¥ä¸Šé¢çš„é€»è¾‘èƒ½ç»´æŠ¤ä¸€ä¸ªå•è°ƒé€’å‡çš„åˆ—è¡¨äº†ï¼Œå…¶å®åè¿‡æ¥æƒ³çªç„¶å°±ä¼šå‘ç°ä¹Ÿå¾ˆç®€å•ï¼Œæˆ‘popæ‰æ¯”æˆ‘å°çš„ï¼Œæˆ‘è¿™ä¸ªlistè‡ªç„¶å°±æ˜¯å•è°ƒé€’å‡çš„ğŸ˜„


æ¬¢è¿æ¥githubä¸Šçœ‹æ›´å¤šé¢˜ç›®çš„è§£ç­”[åŠ›æ‰£è§£é¢˜æ€è·¯](https://github.com/WRAllen/LeetCode)
