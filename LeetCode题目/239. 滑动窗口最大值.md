# é¢˜ç›®[239. æ»‘åŠ¨çª—å£æœ€å¤§å€¼](https://leetcode.cn/problems/sliding-window-maximum/description/?envType=study-plan-v2&envId=top-100-liked)

ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ numsï¼Œæœ‰ä¸€ä¸ªå¤§å°ä¸º k çš„æ»‘åŠ¨çª—å£ä»æ•°ç»„çš„æœ€å·¦ä¾§ç§»åŠ¨åˆ°æ•°ç»„çš„æœ€å³ä¾§ã€‚ä½ åªå¯ä»¥çœ‹åˆ°åœ¨æ»‘åŠ¨çª—å£å†…çš„ k ä¸ªæ•°å­—ã€‚æ»‘åŠ¨çª—å£æ¯æ¬¡åªå‘å³ç§»åŠ¨ä¸€ä½ã€‚

è¿”å› æ»‘åŠ¨çª—å£ä¸­çš„æœ€å¤§å€¼ ã€‚

ç¤ºä¾‹ 1ï¼š

    è¾“å…¥ï¼šnums = [1,3,-1,-3,5,3,6,7], k = 3
    è¾“å‡ºï¼š[3,3,5,5,6,7]
    è§£é‡Šï¼š
    æ»‘åŠ¨çª—å£çš„ä½ç½®                æœ€å¤§å€¼
    ---------------               -----
    [1  3  -1] -3  5  3  6  7       3
    1 [3  -1  -3] 5  3  6  7       3
    1  3 [-1  -3  5] 3  6  7       5
    1  3  -1 [-3  5  3] 6  7       5
    1  3  -1  -3 [5  3  6] 7       6
    1  3  -1  -3  5 [3  6  7]      7

ç¤ºä¾‹ 2ï¼š

    è¾“å…¥ï¼šnums = [1], k = 1
    è¾“å‡ºï¼š[1]
 

æç¤ºï¼š

    1 <= nums.length <= 105
    -10^4 <= nums[i] <= 10^4
    1 <= k <= nums.length

*****

# è§£é¢˜æ€è·¯

ç°åœ¨ä¼šå…ˆçœ‹çœ‹é¢˜ç›®çš„æç¤ºäº†ï¼Œé‡Œé¢å†™äº†æ¯ä¸ªå‚æ•°çš„èŒƒå›´ï¼Œä»¥å‰ä¸çŸ¥é“çœ‹ï¼Œå‡€çæƒ³ï¼Œå°±åˆšåˆšï¼Œæˆ‘è¿˜æƒ³kæ˜¯ä¸æ˜¯ä¼šç­‰äº0ğŸ¤ª

ç°åœ¨çœ‹æ¥ï¼Œå…ˆæ ¹æ®é¢˜ç›®çš„æ„æ€ï¼Œå†™ä¸€ä¸‹æš´åŠ›ç ´è§£

## â˜¹ï¸è§£æ³•1 æš´åŠ›ç ´è§£:

å°±æ˜¯ä¾æ®é¢˜ç›®çš„æ„æ€ï¼Œæ»‘åŠ¨çª—å£çš„æ€è·¯ï¼Œè¿™é‡Œæœ‰ä¸€ä¸ªå°ç‚¹ï¼Œç”±äºå·¦ä¸‹æ ‡ä¹Ÿåœ¨ç§»åŠ¨ï¼Œæ‰€ä»¥æœ‰å¯èƒ½å·¦ä¸‹æ ‡ç§»åŠ¨å‰ä»–æ­£å¥½æ˜¯è¿™kä¸ªæ•°å­—é‡Œé¢æœ€å¤§çš„å€¼

æ‰€ä»¥æš´åŠ›ç ´è§£å°±åœ¨å·¦ä¸‹æ ‡åˆ°å³ä¸‹æ ‡ç¡®å®šçš„æƒ…å†µä¸‹ï¼Œå†éå†ä¸€éï¼Œæ—¶é—´å¤æ‚åº¦ç›´æ¥O(n*m)äº†

### golangä»£ç 1

ä»£ç å¦‚ä¸‹

```go
func maxSlidingWindow(nums []int, k int) []int {
    result := make([]int, 0)
    for leftIndex := 0; leftIndex <= len(nums) - k; leftIndex ++ {
		tmpMax := nums[leftIndex]
		fmt.Println(leftIndex, leftIndex+ k)
		for i := leftIndex; i < leftIndex + k; i ++ {
			if nums[i] > tmpMax {
				tmpMax = nums[i]
			}
		}
		result = append(result, tmpMax)
    }
    return result
}

```

è¿è¡Œç»“æœ
```
è¶…å‡ºæ—¶é—´é™åˆ¶
41 / 51 ä¸ªé€šè¿‡çš„æµ‹è¯•ç”¨ä¾‹
```

è¿™é‡Œè¿™ä¸ªnumæ˜¯ä¸€ä¸ªè¶…çº§å¤§çš„æ•°ç»„(300kb+çš„ä¸€ä¸ªæ•°ç»„),ä¸€å…±64317ä¸ª

k = 32879


## â˜¹ï¸è§£æ³•2 å­—å…¸å­˜å‚¨æ»‘åŠ¨çª—å£å†…çš„ä¿¡æ¯:

ä¸Šé¢æš´åŠ›ç ´è§£åœ¨åšåˆ¤æ–­å¾ªç¯çš„æ—¶å€™ï¼Œå…¶å®åšäº†å¾ˆå¤šæ— ç”¨å·¥ï¼Œå› ä¸ºå˜åŠ¨çš„åªæœ‰å¼€å§‹å’Œç»“æŸçš„2ä½ï¼Œå¯æ˜¯æ¯æ¬¡å´å¾ªç¯äº†kä¸ªæ•°å­—

é—®é¢˜å°±å˜æˆäº† leftIndex ï½ rightIndex è¿™äº›å­èŒƒå›´å†…çš„æœ€å¤§å€¼æ€ä¹ˆåˆ¤æ–­

å…¶å®leftIndexç§»åŠ¨çš„æ—¶å€™ï¼Œæœ‰2ç§æƒ…å†µ

1.leftIndexç§»åŠ¨å‰è¿™ä¸ªä½ç½®çš„æ•°ä¸æ˜¯æœ€å¤§çš„ï¼Œè¿™é‡Œå°±ä¸ä¼šå½±å“åˆ°ç»“æœ

2.leftIndexç§»åŠ¨å‰è¿™ä¸ªä½ç½®çš„æ•°æ˜¯æœ€å¤§çš„

2.1 å½“å‰æœ€å¤§å€¼åœ¨èŒƒå›´å†…åªæœ‰1ä¸ªï¼Œé‚£å°±éœ€è¦æ‰¾å‡ºç¬¬äºŒå¤§

2.2 å½“å‰æœ€å¤§å€¼åœ¨èŒƒå›´å†…æœ‰å¤šä¸ªï¼Œé‚£å°±ä¸å½±å“ç»“æœ

é‚£ä¹ˆå°±éœ€è¦æœ‰åœ°æ–¹èƒ½è®°å½•è¿™äº›å€¼ï¼Œå¹¶ä¸”ä¸æ˜¯ç®€å•çš„è®°å½•ä¸€ä¸‹æœ€å¤§å€¼çš„ä½ç½®ï¼Œ

é‚£å‡è®¾å¦‚æœåªè®°å½•æœ€å¤§å€¼å’Œç¬¬äºŒå¤§å€¼æ˜¯å¦å¯è¡Œå‘¢ï¼Œ

    æ‹¿ä¾‹å­æ•°æ®æ¥ä¸¾ä¾‹
    1,3,-1,-3,5,3,6,7

    1 3 -1 æ—¶ æœ€å¤§3 ç¬¬äºŒå¤§1

    3 -1 -3 è¿™ä¸ªæ—¶å€™ç¬¬äºŒå¤§æ²¡äº†ï¼Œå¹¶ä¸”è¿›æ¥çš„-3æ¯”ä¹‹å‰çš„-1è¿˜è¦å°ï¼Œä½†æ˜¯ç”±äº-1æ²¡è®°å½•ï¼Œæ‰€ä»¥æ•°æ®å°±ä¸¢å¤±äº†
    æ²¡æ³•ç»´æŠ¤3æœ€å¤§ï¼Œ-1ç¬¬äºŒå¤§çš„æƒ…å†µ

æ‰€ä»¥è¿™æ ·ç®€å•çš„è®°å½•æœ€å¤§å€¼å’Œç¬¬äºŒå¤§å€¼æ˜¯ä¸è¡Œçš„ï¼Œéœ€è¦æœ‰ä¸ªæ•°æ®èƒ½ç»´æŠ¤æ»‘åŠ¨çª—å£å†…çš„å€¼çš„æƒ…å†µ

é‚£å¦‚æœæˆ‘ç”¨ä¸€ä¸ªå­—å…¸æŠŠæ»‘åŠ¨çª—å£å†…çš„å€¼å’Œæ•°é‡ç»´æŠ¤èµ·æ¥ï¼Œkeyæ˜¯å½“å‰nums[i]çš„å€¼ï¼Œvaluesæ˜¯å‡ºç°çš„æ¬¡æ•°

å·¦è¾¹å‡ºå»ä¸€ä¸ªï¼Œå°±æŠŠkeyå¯¹åº”çš„values-1ï¼Œå³è¾¹è¿›æ¥ä¸€ä¸ªå°±æŠŠå¯¹åº”çš„values+1

è¿™æ ·å¯ä»¥ç»´æŠ¤çª—å£å†…çš„æ•°æ®æƒ…å†µï¼Œä½†æ˜¯é—®é¢˜åˆæ¥äº†ï¼Œæ¯æ¬¡æ»‘åŠ¨çš„æ˜¯æ—¶å€™éœ€è¦èƒ½çŸ¥é“å½“å‰è¿™ä¸ªå­—å…¸é‡Œé¢çš„æœ€å¤§keyæ˜¯å•¥

è¿™é‡Œå¦‚æœé€šè¿‡éå†æ‰€æœ‰keyå»å–å€¼çš„è¯ï¼Œç†è®ºä¸Šå’Œä¸Šé¢çš„æš´åŠ›ç ´è§£åœ¨æŸäº›ç‰¹æ®Šcaseä¸Šå¤æ‚åº¦åº”è¯¥æ˜¯å·®ä¸å¤šçš„ï¼Œè¿™é‡Œå°±å˜æˆéœ€è¦çŸ¥é“æœ€å¤§çš„keyæ˜¯å•¥
ä½†æ˜¯è¿™æœ‰ç‚¹æœ¬æœ«å€’ç½®äº†ï¼Œæˆ‘è¦æ˜¯çŸ¥é“æœ€å¤§çš„keyæ˜¯å•¥ï¼Œæˆ‘è¿˜ç”¨å•¥å­—å…¸æ¥å­˜å‚¨å¤šä½™çš„æ•°æ®

ä¸Šé¢è¿™ç§æƒ…å†µåº”è¯¥é€‚ç”¨äºnums[i]çš„å–å€¼èŒƒå›´ç›¸å¯¹è¾ƒå°çš„caseï¼Œè¿™æ ·çŸ¥é“èŒƒå›´ï¼Œå¯ä»¥ä»å¤§åˆ°å°éå†å­—å…¸ï¼Œ
å‘ç°values>0å°±è¯´æ˜æ‰¾åˆ°æœ€å¤§å€¼äº†

ä½†æ˜¯é¢˜ç›®çš„nums[i]èŒƒå›´å¤ªå¤§äº†ï¼Œæœ¬é¢˜ä¸é€‚åˆç”¨è¿™ç§æ–¹å¼


## è§£æ³•3 æœ€å¤§å †

å½“æ•°ç»„å’Œå­—å…¸è§£å†³ä¸äº†é—®é¢˜çš„æ—¶å€™ï¼Œå°±è¦æ€è€ƒæœ‰æ²¡æœ‰å…¶ä»–æ•°æ®ç»“æ„èƒ½è§£å†³è¿™ä¸ªé—®é¢˜äº†

ä¹‹å‰æœ‰è€ƒè™‘è¿‡å †ï¼Œä½†æ˜¯å¯¹è¿™ä¸ªæ•°æ®ç»“æ„ä¸å¤ªæ¸…æ™°ï¼Œå°±æ²¡å¾€è¿™æ–¹é¢è€ƒè™‘ï¼ˆçœ‹äº†å®˜æ–¹é¢˜è§£ï¼ŒçŸ¥é“ç”¨æœ€å¤§å †ï¼‰

ä¸‹é¢æ¥å¤ä¹ ä¸€ä¸‹ï¼Œæœ€å¤§å †ï¼ˆMax Heapï¼‰

æœ€å¤§å †æ˜¯ä¸€ç§å®Œå…¨äºŒå‰æ ‘ï¼Œå¹¶ä¸”æ»¡è¶³æ¯ä¸ªèŠ‚ç‚¹çš„å€¼éƒ½å¤§äºæˆ–è€…ç­‰äºå…¶å­èŠ‚ç‚¹çš„å€¼

è¿™æ ·æ»‘åŠ¨çš„æ—¶å€™ï¼Œæ¯æ¬¡å–rootçš„å€¼ï¼Œå°±å¯ä»¥è·å–åˆ°ç»“æœäº†ï¼Œé‚£æœ€å¤§å †æ˜¯å¦‚ä½•åšåˆ°è§£æ³•2é‡Œé¢mapåšä¸åˆ°çš„äº‹æƒ…å‘¢

golangé‡Œé¢ç”¨ä¸€ä¸ªlistç»´æŠ¤äº†è¿™ä¸ªå †ï¼Œè¿™ä¸ªlistçš„é¡ºåºï¼Œä»£è¡¨äº†ä»rootï¼Œç„¶åä¾æ¬¡å‘ä¸‹ï¼Œä»å·¦åˆ°å³ï¼Œåˆ°æœ€åº•å±‚

æ¯”å¦‚ä¸€ä¸ªå¦‚ä¸‹çš„å †ï¼ˆå·¦è¾¹èŠ‚ç‚¹ä¸ç”¨ä¸€å®šæ¯”å³è¾¹èŠ‚ç‚¹å¤§ï¼‰:

           50
          /  \
        30    40
        / \    / \
       10 20  35 25      


åœ¨golangå­˜å‚¨æ˜¯è¿™æ ·çš„:

    {50, 30, 40, 10, 20, 35, 25}

ç¬¬[0]ä½æ˜¯æœ€å¤§å€¼

è¿™é‡Œå°±æœ‰å‡ ä¸ªå®šç†å¦‚æœå½“å‰çš„ä¸‹æ ‡æ˜¯iï¼Œé‚£ä¹ˆ

ä»–çš„çˆ¶èŠ‚ç‚¹çš„åæ ‡=(i-1)/2(æ•´é™¤2ï¼Œå¹¶ä¸”i>0)

å·¦å­èŠ‚ç‚¹=i*2+1

å³å­èŠ‚ç‚¹=i*2+2


ä¸‹é¢ç”¨golangå®ç°ä¸€ä¸‹æœ€å¤§å †
```go
package main

import "fmt"

type MaxHeap struct {
	data []int
}

// æ’å…¥å…ƒç´ ,æŠŠå…ƒç´ æ·»åŠ åˆ°å°¾éƒ¨ï¼Œæ‰§è¡Œä¸Šæµ®æ“ä½œ
func (h *MaxHeap) Push(x int) {
	h.data = append(h.data, x)
	h.up(len(h.data) - 1)
}

// å¼¹å‡ºæœ€å¤§å…ƒç´ ï¼Œ æŠŠå°¾å·´å…ƒç´ æ›¿æ¢å½“å‰çš„å †é¡¶ï¼Œæ‰§è¡Œä¸‹æµ®æ“ä½œ
func (h *MaxHeap) Pop() int {
	if len(h.data) == 0 {
		panic("heap is empty")
	}
	max := h.data[0]
	last := h.data[len(h.data)-1]
	h.data = h.data[:len(h.data)-1]
	if len(h.data) > 0 {
		h.data[0] = last
		h.down(0)
	}
	return max
}

// è·å–å †é¡¶
func (h *MaxHeap) Peek() int {
	if len(h.data) == 0 {
		panic("heap is empty")
	}
	return h.data[0]
}

// ä¸Šæµ®æ“ä½œ æ¯”è¾ƒå½“å‰çˆ¶èŠ‚ç‚¹çš„å€¼ï¼Œå¦‚æœæ¯”çˆ¶èŠ‚ç‚¹å¤§ï¼Œå°±æ›¿æ¢çˆ¶èŠ‚ç‚¹
func (h *MaxHeap) up(index int) {
	for index > 0 {
		parent := (index - 1) / 2
		if h.data[parent] >= h.data[index] {
			break
		}
		h.data[parent], h.data[index] = h.data[index], h.data[parent]
		index = parent
	}
}

// ä¸‹æ²‰æ“ä½œ
func (h *MaxHeap) down(index int) {
	n := len(h.data)
	for {
		left := 2*index + 1
		right := 2*index + 2
		largest := index

		if left < n && h.data[left] > h.data[largest] {
			largest = left
		}
		if right < n && h.data[right] > h.data[largest] {
			largest = right
		}
        // å¦‚æœå½“å‰çš„indexå°±æ˜¯æœ€å¤§çš„ï¼Œç»“æŸä¸‹æ²‰æ¾³æ´²
		if largest == index {
			break
		}
        // æŠŠå½“å‰ä¸‹æ ‡æ‰€åœ¨çš„å’Œæœ€å¤§çš„å­èŠ‚ç‚¹è°ƒæ¢ä½ç½®
		h.data[index], h.data[largest] = h.data[largest], h.data[index]
        // æŠŠå½“å‰åæ ‡è®¾ç½®æˆä¹‹å‰çš„å­èŠ‚ç‚¹åæ ‡ï¼Œç„¶åé€’å½’ï¼Œå†æ¬¡åšä¸‹æ²‰æ“ä½œ
		index = largest
	}
}

func main() {
	h := &MaxHeap{}
	h.Push(3)
	h.Push(10)
	h.Push(5)
	h.Push(1)

	fmt.Println("å †é¡¶:", h.Peek()) // 10

	for len(h.data) > 0 {
		fmt.Println(h.Pop()) // è¾“å‡ºé¡ºåº: 10, 5, 3, 1
	}
}
```

æœ‰äº†ä¸Šé¢çš„æœ€å¤§å †ï¼Œé‚£è¿˜æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œæ€ä¹ˆæŠŠæœ€å·¦è¾¹è¿™ä¸ªå…ƒç´ ä»æœ€å¤§å †é‡Œé¢popå‡ºå»å‘¢ï¼Œè¿™é‡Œå¯ä»¥æ‹“å±•ä¸€ä¸‹æœ€å¤§å †å­˜å‚¨çš„æ•°æ®

å¯ä»¥æŠŠå †é‡Œé¢å­˜å‚¨ä¸€ä¸ªç»“æ„ä½“ï¼Œè¿™ä¸ªç»“æ„ä½“ï¼Œé‡Œé¢æœ‰ä¸€ä¸ªvalueå€¼ï¼Œå’Œä¸€ä¸ªå½“å‰valueså€¼çš„ä¸‹æ ‡

åœ¨çª—å£æ»‘åŠ¨çš„æ—¶å€™ï¼Œå¦‚æœå½“å‰æœ€å¤§å †çš„rootï¼Œåœ¨ä¸‹æ ‡ä¸åœ¨å½“å‰çš„æ»‘åŠ¨çª—å£é‡Œé¢ï¼Œé‚£å°±å¯ä»¥ä¸€ç›´popï¼ŒçŸ¥é“ä¸‹æ ‡åœ¨çª—å£é‡Œé¢

è¿™æ ·å½“å‰rootçš„valueså°±æ˜¯å½“å‰æœ€å¤§çš„å€¼ï¼Œæ‰€ä»¥ä¿®æ”¹ä¸€ä¸‹å¦‚ä¸Šä»£ç å¦‚ä¸‹


```go
package main

import "fmt"


type Item struct {
	value int
	index int
}

type MaxHeap struct {
	data []Item
}

// æ’å…¥å…ƒç´ ,æŠŠå…ƒç´ æ·»åŠ åˆ°å°¾éƒ¨ï¼Œæ‰§è¡Œä¸Šæµ®æ“ä½œ
func (h *MaxHeap) Push(each Item) {
	h.data = append(h.data, each)
	h.up(len(h.data) - 1)
}

// å¼¹å‡ºæœ€å¤§å…ƒç´ ï¼Œ æŠŠå°¾å·´å…ƒç´ æ›¿æ¢å½“å‰çš„å †é¡¶ï¼Œæ‰§è¡Œä¸‹æµ®æ“ä½œ
func (h *MaxHeap) Pop() Item {
	if len(h.data) == 0 {
		panic("heap is empty")
	}
	max := h.data[0]
	last := h.data[len(h.data)-1]
	h.data = h.data[:len(h.data)-1]
	if len(h.data) > 0 {
		h.data[0] = last
		h.down(0)
	}
	return max
}

// è·å–å †é¡¶
func (h *MaxHeap) Peek() Item {
	if len(h.data) == 0 {
		panic("heap is empty")
	}
	return h.data[0]
}

// ä¸Šæµ®æ“ä½œ æ¯”è¾ƒå½“å‰çˆ¶èŠ‚ç‚¹çš„å€¼ï¼Œå¦‚æœæ¯”çˆ¶èŠ‚ç‚¹å¤§ï¼Œå°±æ›¿æ¢çˆ¶èŠ‚ç‚¹
func (h *MaxHeap) up(index int) {
	for index > 0 {
		parent := (index - 1) / 2
		if h.data[parent].value >= h.data[index].value {
			break
		}
		h.data[parent], h.data[index] = h.data[index], h.data[parent]
		index = parent
	}
}

// ä¸‹æ²‰æ“ä½œ
func (h *MaxHeap) down(index int) {
	n := len(h.data)
	for {
		left := 2*index + 1
		right := 2*index + 2
		largest := index

		if left < n && h.data[left].value > h.data[largest].value {
			largest = left
		}
		if right < n && h.data[right].value > h.data[largest].value {
			largest = right
		}
        // å¦‚æœå½“å‰çš„indexå°±æ˜¯æœ€å¤§çš„ï¼Œç»“æŸä¸‹æ²‰æ¾³æ´²
		if largest == index {
			break
		}
        // æŠŠå½“å‰ä¸‹æ ‡æ‰€åœ¨çš„å’Œæœ€å¤§çš„å­èŠ‚ç‚¹è°ƒæ¢ä½ç½®
		h.data[index], h.data[largest] = h.data[largest], h.data[index]
        // æŠŠå½“å‰åæ ‡è®¾ç½®æˆä¹‹å‰çš„å­èŠ‚ç‚¹åæ ‡ï¼Œç„¶åé€’å½’ï¼Œå†æ¬¡åšä¸‹æ²‰æ“ä½œ
		index = largest
	}
}


func main() {
	h := &MaxHeap{}
	h.Push(Item{value: 3, index: 0})
	h.Push(Item{value: 10, index: 1})
	h.Push(Item{value: 5, index: 2})
	h.Push(Item{value: 1, index: 3})

	fmt.Println("å †é¡¶:", h.Peek())

	for len(h.data) > 0 {
		fmt.Println(h.Pop())
	}
}
```

æµ‹è¯•æ²¡é—®é¢˜äº†ï¼Œå¼€å§‹ç»“åˆé¢˜ç›®ï¼Œå…ˆåˆå§‹åŒ–è¿™ä¸ªæœ€å¤§å †ï¼Œç„¶åå¼€å§‹æ»‘åŠ¨ï¼Œæ»‘åŠ¨çš„æ—¶å€™å…ˆæŠŠä¸‹æ ‡çš„ä¿¡æ¯appendåˆ°å †é‡Œé¢

ç„¶åå¼€å§‹åˆ¤æ–­å½“å‰å †çš„rootæ˜¯å¦åœ¨æ»‘åŠ¨çª—å£é‡Œé¢ï¼Œä¸åœ¨å°±è¿›è¡Œpopæ“ä½œï¼ŒçŸ¥é“åœ¨æ»‘åŠ¨çª—å£é‡Œé¢ï¼Œé‚£è¿™ä¸ªæ—¶å€™çš„rootå°±æ˜¯æœ€å¤§çš„å€¼

æŠŠrootçš„å€¼è¿½åŠ åˆ°ç»“æœé‡Œé¢ï¼Œæœ€åè¿”å›ç»“æœå³å¯



### golangä»£ç 1
```go
package main

import "fmt"


type Item struct {
	value int
	index int
}

type MaxHeap struct {
	data []Item
}

// æ’å…¥å…ƒç´ ,æŠŠå…ƒç´ æ·»åŠ åˆ°å°¾éƒ¨ï¼Œæ‰§è¡Œä¸Šæµ®æ“ä½œ
func (h *MaxHeap) Push(each Item) {
	h.data = append(h.data, each)
	h.up(len(h.data) - 1)
}

// å¼¹å‡ºæœ€å¤§å…ƒç´ ï¼Œ æŠŠå°¾å·´å…ƒç´ æ›¿æ¢å½“å‰çš„å †é¡¶ï¼Œæ‰§è¡Œä¸‹æµ®æ“ä½œ
func (h *MaxHeap) Pop() Item {
	if len(h.data) == 0 {
		panic("heap is empty")
	}
	max := h.data[0]
	last := h.data[len(h.data)-1]
	h.data = h.data[:len(h.data)-1]
	if len(h.data) > 0 {
		h.data[0] = last
		h.down(0)
	}
	return max
}

// è·å–å †é¡¶
func (h *MaxHeap) Peek() Item {
	if len(h.data) == 0 {
		panic("heap is empty")
	}
	return h.data[0]
}

// ä¸Šæµ®æ“ä½œ æ¯”è¾ƒå½“å‰çˆ¶èŠ‚ç‚¹çš„å€¼ï¼Œå¦‚æœæ¯”çˆ¶èŠ‚ç‚¹å¤§ï¼Œå°±æ›¿æ¢çˆ¶èŠ‚ç‚¹
func (h *MaxHeap) up(index int) {
	for index > 0 {
		parent := (index - 1) / 2
		if h.data[parent].value >= h.data[index].value {
			break
		}
		h.data[parent], h.data[index] = h.data[index], h.data[parent]
		index = parent
	}
}

// ä¸‹æ²‰æ“ä½œ
func (h *MaxHeap) down(index int) {
	n := len(h.data)
	for {
		left := 2*index + 1
		right := 2*index + 2
		largest := index

		if left < n && h.data[left].value > h.data[largest].value {
			largest = left
		}
		if right < n && h.data[right].value > h.data[largest].value {
			largest = right
		}
        // å¦‚æœå½“å‰çš„indexå°±æ˜¯æœ€å¤§çš„ï¼Œç»“æŸä¸‹æ²‰æ¾³æ´²
		if largest == index {
			break
		}
        // æŠŠå½“å‰ä¸‹æ ‡æ‰€åœ¨çš„å’Œæœ€å¤§çš„å­èŠ‚ç‚¹è°ƒæ¢ä½ç½®
		h.data[index], h.data[largest] = h.data[largest], h.data[index]
        // æŠŠå½“å‰åæ ‡è®¾ç½®æˆä¹‹å‰çš„å­èŠ‚ç‚¹åæ ‡ï¼Œç„¶åé€’å½’ï¼Œå†æ¬¡åšä¸‹æ²‰æ“ä½œ
		index = largest
	}
}

func maxSlidingWindow(nums []int, k int) []int {
    result := make([]int, 0)
    maxHeap := &MaxHeap{}
	for i := 0; i < k; i++ {
		maxHeap.Push(Item{
			value: nums[i],
			index: i,
		})
	}
	result = append(result, maxHeap.Peek().value)
	// å¼€å§‹æ»‘åŠ¨
	for i := k; i < len(nums); i++ {
		maxHeap.Push(Item{
			value: nums[i],
			index: i,
		})
		for {
			root := maxHeap.Peek()
			// å½“å‰rootèŠ‚ç‚¹çš„ä¸‹æ ‡å¦‚æœåœ¨æ»‘åŠ¨çª—å£çš„å·¦è¾¹ï¼Œå°±è¯´æ˜å½“å‰rootä¸åœ¨æ»‘åŠ¨çª—å£é‡Œé¢ï¼Œéœ€è¦å¼¹å‡º
			if root.index <= i - k {
				maxHeap.Pop()
			} else {
                // è¯´æ˜rootåœ¨æ»‘åŠ¨çª—å£é‡Œé¢äº†
                break
            }
			
		}
		root := maxHeap.Peek()
		result = append(result, root.value)		
	}

    return result
}
```

è¿è¡Œç»“æœ
```
æ‰§è¡Œç”¨æ—¶åˆ†å¸ƒ
39ms å‡»è´¥15.52%

æ¶ˆè€—å†…å­˜åˆ†å¸ƒ
11.50MB å‡»è´¥6.81%
```


### pythonä»£ç 1

```python
# from dataclasses import dataclass
# æ˜¯python3.7åŠ å…¥çš„æ ‡å‡†åº“ï¼Œç®€åŒ–æ•°æ®ç±»çš„å®šä¹‰ï¼Œå¯ä¸ä½ ä¸ç”¨å†™initï¼Œreprï¼Œeqè¿™äº›
@dataclass
class Item:
    value: int
    index: int

class MaxHeap:
    def __init__(self):
        self.data = []
    
    def push(self, item: Item):
        self.data.append(item)
        self._up(len(self.data)-1)

    def pop(self) -> Item:
        if len(self.data) == 0:
            return None
        max_item = self.data[0]
        last = self.data[-1]
        self.data = self.data[:-1]
        if len(self.data) > 0:
            self.data[0] = last
            self._down(0)
        return max_item
    
    def peek(self) -> Item:
        if len(self.data) == 0:
            return None
        return self.data[0]
    
    def _up(self, i: int):
        while i > 0:
            p_i = (i-1) // 2
            if self.data[i].value <= self.data[p_i].value:
                break
            self.data[i], self.data[p_i] = self.data[p_i], self.data[i]
            i = p_i

    def _down(self, i: int):
        n = len(self.data)
        while True:
            l_i = i * 2 + 1
            r_i = i * 2 + 2
            # å…ˆå‡è®¾å½“å‰çš„ä¸‹æ ‡å°±æ˜¯æœ€å¤§å€¼çš„ä¸‹æ ‡
            max_i = i
            if l_i < n and self.data[l_i].value > self.data[max_i].value:
                max_i = l_i
            if r_i < n and self.data[r_i].value > self.data[max_i].value:
                max_i = r_i
            if max_i == i:
                break
            self.data[i], self.data[max_i] = self.data[max_i], self.data[i]
            # æŠŠå½“å‰åæ ‡å’Œå­æœ€å¤§åæ ‡æ›¿æ¢ï¼Œç„¶åè¿­ä»£ï¼Œç»§ç»­ä¸‹æ²‰
            i = max_i

class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        result = []
        heap = MaxHeap()
        for i in range(k):
            heap.push(Item(index=i, value=nums[i]))
        root = heap.peek()
        result.append(root.value)
        for i in range(k, len(nums)):
            heap.push(Item(index=i, value=nums[i]))
            while True:
                root = heap.peek()
                if root.index <= i - k:
                    heap.pop()
                else:
                    break
            root = heap.peek()
            result.append(root.value)
            
        return result

```

è¿è¡Œç»“æœ
```
è¶…å‡ºæ—¶é—´é™åˆ¶
47 / 51 ä¸ªé€šè¿‡çš„æµ‹è¯•ç”¨ä¾‹
```

ç«Ÿç„¶è¶…æ—¶äº†ï¼Œæ— è¯­ï¼Œç®—äº†ç®—äº†ï¼Œå…ˆè¿™æ ·


æ¬¢è¿æ¥githubä¸Šçœ‹æ›´å¤šé¢˜ç›®çš„è§£ç­”[åŠ›æ‰£è§£é¢˜æ€è·¯](https://github.com/WRAllen/LeetCode)
