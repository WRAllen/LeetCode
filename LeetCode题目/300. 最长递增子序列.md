# 题目[300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/description/?envType=study-plan-v2&envId=top-100-likedxxxx)

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

 
示例 1：

    输入：nums = [10,9,2,5,3,7,101,18]
    输出：4
    解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
示例 2：

    输入：nums = [0,1,0,3,2,3]
    输出：4
示例 3：

    输入：nums = [7,7,7,7,7,7,7]
    输出：1
 

提示：

    1 <= nums.length <= 2500
    -104 <= nums[i] <= 104
 

进阶：

    你能将算法的时间复杂度降低到 O(n log(n)) 吗?

*****

# 解题思路

一眼就开出来是个动态规划的题目(只是因为我是热题100那边的动态规划题目里面点进来的:D)

## 解法1 动态规划:

老样子，动态规划，最重要的就是dp数组

已知dp[n] 就是nums里面下标为n时，严格递增子序列的长度（因为dp数组就是包含答案的数组）

所以最大的问题就是如何组织出这个dp数组，也就是n和n-1获取在n前面的有什么关联，

假设dp[n]存储的就是结果，那现在重要的是dp的推导示，这里想了半天没有头绪

而且把问题越想越复杂了，看了一下[官方解答](https://leetcode.cn/problems/longest-increasing-subsequence/solutions/147667/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/?envType=study-plan-v2&envId=top-100-liked) 恍然大悟

之前只考虑当n为i的时候，后面的数据要怎么处理，没想到呀，没想到，这种想法已经背离了动态规划了

因为动态规划里面n一定是和前面有关系的，所以处理n的时候如果往n+1，n+x这方向想，只会越来越跑偏


本题的思路也很简单，求取n的时候，i从0～n-1进行判断，如果当前i的值比n的值要小，说明i是可以接上n的

这个时候只需要认为dp[i]里面的值已经是处理好的，下面直接上代码


### golang代码

```go
func lengthOfLIS(nums []int) int {
	dp := make([]int, 0)
	for i := range(len(nums)) {
		// 不过后续如何，总有一种选择，就是从当前这个i开始作为一个子序列
        // 其实如果不在这里append，那在准备dp的时候，就可以搞一个长度为len(nums)，值都是1的dp
        // 由于go里面不能很优雅的写，所以写这里比较好
        // 可以对比python和rust，直接初始化的时候都置为1
		dp = append(dp, 1)
		// 遍历比i小的前面的数据
		for j := range(i) {
			// 之前对应的nums值比i的小，才有可能在i前面组成递增子序列
			if nums[j] < nums[i] {
				// 根据他们的dp值，获取个最大的
				dp[i] = max(dp[i], dp[j]+1)
			}
			
		}
	}
	maxNum := 0
	for _, num := range dp {
		maxNum = max(maxNum, num)
	}

	return maxNum
}

```

运行结果
```
执行用时分布
42ms 击败60.11%

消耗内存分布
5.79MB 击败5.00%
```

### python代码

翻译为py

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        dp = [1] * len(nums)
        for i, num in enumerate(nums):
            for j in range(i):
                if num > nums[j]:
                    dp[i] = max(dp[i], dp[j]+1)
        return max(dp)
```

py依旧是这么短:D

运行结果
```
执行用时分布
1147ms 击败77.50%

消耗内存分布
19.25MB 击败17.76%
```

### rust代码

rust来咯

```rust
impl Solution {
    pub fn length_of_lis(nums: Vec<i32>) -> i32 {
        let mut dp: Vec<i32> = vec![1; nums.len()];
        for i in 0..nums.len(){
            for j in 0..i{
                if nums[i] > nums[j] {
                    dp[i] = dp[i].max(dp[j]+1)
                }
            }
        }
        *dp.iter().max().unwrap()
    }
}
```

运行结果
```
执行用时分布
48ms 击败26.92%

消耗内存分布
2.23MB 击败41.35%
```

欢迎来github上看更多题目的解答[力扣解题思路](https://github.com/WRAllen/LeetCode)
