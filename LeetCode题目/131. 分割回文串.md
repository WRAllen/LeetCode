# é¢˜ç›®[131. åˆ†å‰²å›æ–‡ä¸²](https://leetcode.cn/problems/palindrome-partitioning/description/?envType=study-plan-v2&envId=top-100-liked)

ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² sï¼Œè¯·ä½ å°† s åˆ†å‰²æˆä¸€äº› å­ä¸²ï¼Œä½¿æ¯ä¸ªå­ä¸²éƒ½æ˜¯ å›æ–‡ä¸² ã€‚è¿”å› s æ‰€æœ‰å¯èƒ½çš„åˆ†å‰²æ–¹æ¡ˆã€‚

 

ç¤ºä¾‹ 1ï¼š

    è¾“å…¥ï¼šs = "aab"
    è¾“å‡ºï¼š[["a","a","b"],["aa","b"]]
ç¤ºä¾‹ 2ï¼š

    è¾“å…¥ï¼šs = "a"
    è¾“å‡ºï¼š[["a"]]
 

æç¤ºï¼š

    1 <= s.length <= 16
    s ä»…ç”±å°å†™è‹±æ–‡å­—æ¯ç»„æˆ

*****

# è§£é¢˜æ€è·¯

æœ‰ç‚¹å¿˜è®°ï¼Œå•¥æ˜¯å›æ–‡ä¸²äº†ï¼Œå°±æ˜¯æ­£è¯»å’Œåè¯»éƒ½æ˜¯ä¸€æ ·çš„å­—ç¬¦ä¸²ï¼Œæ¯”å¦‚level

## è§£æ³•1 é€’å½’:

é¢˜ç›®è¯´æ˜¯åˆ†å‰²ï¼Œä¹Ÿå°±æ˜¯è¿˜æ˜¯æŒ‰ç…§ä¹‹å‰çš„å­—ç¬¦ä¸²é¡ºåºè¿›è¡Œåˆ‡å‰²ï¼Œæ¯”å¦‚é•¿åº¦ä¸º4çš„å­—ç¬¦ä¸²ï¼Œä»–å¯ä»¥1ä¸ªå­—ç¬¦åˆ†ä¸€ä¸ªï¼Œ

ä¹Ÿå¯ä»¥2ä¸ªå­—ç¬¦åˆ†2ä¸ªï¼Œä¹Ÿå¯ä»¥3ä¸ªå­—ç¬¦+1ä¸ªå­—ç¬¦åˆ†2ä¸ªï¼Œä¸æ˜¯æŒ‰ç…§æ»‘åŠ¨çª—å£é‚£æ ·çš„æ€è·¯ï¼Œåªå…³æ³¨çª—å£å†…çš„æ•°æ®ï¼ˆä¾‹å¦‚å®ä¾‹1ï¼‰ï¼Œçª—å£å¤–çš„ä¹Ÿé‡è¦

å½“ç„¶è¿˜æœ‰æœ€é‡è¦çš„ä¸€ç‚¹ï¼Œåˆ‡å‰²å®Œçš„<b>æ¯ä¸€ä¸ªå­å­—ç¬¦ä¸²éƒ½è¦æ˜¯å›æ–‡</b>

æ‰€ä»¥æ€ä¹ˆåˆ‡åˆ†è¿™ä¸ªæ€è·¯å¾ˆé‡è¦ï¼Œé‚£æ€ä¹ˆæ‰¾è§„å¾‹å‘¢ï¼Œå°±è¦çœ‹ä¸€ä¸‹é¢˜ç›®çš„ä¾‹å­äº†ï¼Œé¢˜ç›®çš„ä¾‹å­ç»™çš„å¤ªç®€å•äº†ï¼Œä¸‹é¢æ‹“å±•ä¸€ä¸‹

æ¯”å¦‚å­—ç¬¦ä¸²s="aabccb",ä»–é¦–å…ˆæ¯ä¸ªå­—ç¬¦éƒ½æ˜¯ä¸€ä¸ªå›æ–‡ï¼Œå°±æœ‰["a", "a", "b", "c", "c", "b"]

ç„¶åæ˜¯2ä¸ªå­—ç¬¦ä¸²ï¼Œé‚£æœ‰["aa", "bccb"], ["aa", "b", "cc", "b"], ["aa", "b", "c", "c", "b"]

è¿™é‡Œçªç„¶æœ‰ç§æƒ³æš´åŠ›éƒ½ä¸çŸ¥é“æ€ä¹ˆæš´åŠ›çš„æ— åŠ›æ„ŸğŸ˜£

ä½†æ˜¯çªç„¶æœ‰ä¸ªæ€è·¯ï¼Œæ˜¯ä¸æ˜¯å¯ä»¥ç”¨é€’å½’çš„æ–¹æ³•æ¥è§£å†³é—®é¢˜å‘¢ï¼Œå› ä¸ºå­—ç¬¦ä¸²ä¸ç®¡æœ‰å‡ ç§å›æ–‡ï¼Œä»–æ¯ä¸ªå­—ç¬¦æ‹†å¼€ä¸º1ä¸ª1ä¸ªï¼Œé‚£è‚¯å®šä¹Ÿæ˜¯ä¸€ç§å›æ–‡

å‡è®¾så¯ä»¥è¢«åˆ†ä¸ºå›æ–‡çš„s1ï¼Œå’Œä¸ç¡®å®šçš„s2ï¼Œé‚£s2å°±å¯ä»¥ç»§ç»­é€’å½’è°ƒç”¨æœ¬æ–¹æ³•å»åˆ¤æ–­ï¼Œé‚£æ„Ÿè§‰å¯ä»¥ä»0å¼€å§‹ï¼Œä¸æ–­å¾€ååˆ¤æ–­

é‚£ä¹ˆæˆ‘ä»¬å°±å…ˆéœ€è¦ä¸€ä¸ªå›æ–‡å­—ç¬¦ä¸²çš„åˆ¤æ–­å‡½æ•°ï¼Œç”¨ä¸¤ä¸ªæŒ‡é’ˆï¼Œä»å¤´å°¾å¾€ä¸­é—´ç§»åŠ¨åˆ¤æ–­ï¼Œä»£ç å¦‚ä¸‹

```go
func isPalindrome(s string) bool {
    if len(s) == 1{
        return true
    }
    l := 0
    r := len(s) - 1
    for l < r {
        if s[l] != s[r] {
            return false
        }
        l += 1
        r -= 1
    }
    return true
}
```

ç®€å•æµ‹è¯•åï¼Œå‘ç°åº”è¯¥é—®é¢˜ä¸å¤§ï¼Œæ¥ä¸‹æ¥å°±æ˜¯æŠŠä¸Šé¢çš„é€»è¾‘å†™æˆä»£ç äº†ï¼Œé˜¶æ®µæ€§ä»£ç å¦‚ä¸‹
```go
func partition(s string) [][]string {
    result := make([][]string, 0)
    // å›æ–‡çš„é•¿åº¦,ä»1åˆ°max
    for l := 1; l <= len(s); l ++ {
        tmp := make([]string, 0)
        // å·¦è¾¹è¿™ä¸ªå›æ–‡
        firstStr := s[0:l]
        if isPalindrome(firstStr) {
            secondStr := s[l:]
            fmt.Println("first:", firstStr, "second", secondStr)
            // è¿™é‡Œæ—¶å€™å¦‚æœsecondStrè¢«æŸä¸ªå‡½æ•°å¤„ç†äº†ï¼Œè¿”å›è¿™ä¸ªå­å­—ç¬¦ä¸²çš„æ‰€æœ‰å›æ–‡åˆ‡ç‰‡
            // é‚£firstStr+æŸå‡½æ•°å¤„ç†çš„å›æ–‡åˆ‡ç‰‡ï¼Œé‚£ä¹ˆå°±æ˜¯ä¸€ä¸ªç»“æœ
            // é‚£ä¹ˆé—®é¢˜æ¥äº†ï¼Œè¿™ä¸ªæŸå‡½æ•°æ€ä¹ˆæœ‰ç‚¹ä¼¼æˆç›¸è¯†å‘¢ï¼Œæˆ‘é ï¼Œç°åœ¨å†™çš„è¿™ä¸ªä¸å°±æ˜¯å—[doge]
            // æ‰€ä»¥ä¸€å®šæ˜¯é€’å½’è°ƒç”¨ï¼Œè¿™é‡Œæ€è·¯æœ‰ç‚¹ä¹±äº†ï¼Œå…ˆprintä¸€ä¸‹çœ‹çœ‹æ•°æ®
        }
        if len(tmp) > 0 {
            result = append(result, tmp)
        }
    }

    return result
}
```
ç”¨è‡ªæµ‹ä¾‹å­`s := "aabccb"`ï¼Œä¸Šè¿°ä»£ç è¾“å‡ºå¦‚ä¸‹
```
first: a second abccb
first: aa second bccb
```

å†™ç€å†™ç€é‡åˆ°é—®é¢˜äº†ï¼Œè¿™é‡Œè¿™ä¸ªé€’å½’çš„ç»“æœå’Œresultæœ‰ç‚¹é—®é¢˜ï¼Œå¦‚æœé€’å½’çš„è¯ï¼Œé€’å½’å‡½æ•°é‡Œé¢è‚¯å®šæ˜¯ä¸èƒ½å®šä¹‰resultï¼Œå› ä¸ºresultçš„å£°æ˜ä¼šè¢«è¦†ç›–ï¼ˆè¯è¯´æ—©äº†ï¼‰

è¿™é‡Œè¶Šæƒ³è¶Šä¹±ï¼Œå†¥å†¥ä¹‹ä¸­æ„Ÿè§‰å¦‚æœé€’å½’å‡½æ•°é‡Œé¢å¸¦resultçš„è¯ï¼Œä¼šæœ‰å„ç§ç†ä¸æ¸…æ¥šçš„åœ°ï¼ˆä¸‹é¢å…‰é€Ÿæ‰“è„¸ï¼‰

```go
package main

import (
	"fmt"
)

func isPalindrome(s string) bool {
    if len(s) == 1{
        return true
    }
    l := 0
    r := len(s) - 1
    for l < r {
        if s[l] != s[r] {
            return false
        }
        l += 1
        r -= 1
    }
    return true
}

func _partition(s string, result *[][]string) [][]string {
    tmpResult := make([][]string, 0)
    // å›æ–‡çš„é•¿åº¦,ä»1åˆ°max
    for l := 1; l <= len(s); l ++ {
        // å·¦è¾¹è¿™ä¸ªå›æ–‡
        firstStr := s[0:l]
        if isPalindrome(firstStr) {
            secondStr := s[l:]
            // è¿™é‡Œç¬¬äºŒä¸ªä¸ºç©ºäº†ï¼Œè¯´æ˜å‰é¢é‚£ä¸€ä¸²éƒ½æ˜¯å›æ–‡ï¼Œæ‰€ä»¥è¿™é‡Œå°±å¯ä»¥ç›´æ¥æŠŠfirstStråŠ å…¥ä¸´æ—¶åˆ—è¡¨é‡Œé¢
            if secondStr == ""{
                tmpResult = append(tmpResult, []string{firstStr})
                return tmpResult
            }
            fmt.Println("firstStr", firstStr, "secondStr", secondStr)
            tmp := _partition(secondStr, result)
            fmt.Println("tmp:", tmp)
            // è¯´æ˜secondStrè¿™ä¸ªé‡Œé¢ä¹Ÿæœ‰å›æ–‡å­—ç¬¦ä¸²
            // å°±å¯ä»¥æŠŠfirstStræ‹¼æ¥åˆ°ä»–ä»¬åˆ—è¡¨ç¬¬ä¸€ä¸ªçš„ä½ç½®
            if len(tmp) > 0{
                for i := range tmp {
                    tmpLevel := make([]string, 0)
                    tmpLevel = append(tmpLevel, firstStr)
                    tmpLevel = append(tmpLevel, tmp[i]...)
                    tmpResult = append(tmpResult, tmpLevel)
                }
            }
        }
    }
    return tmpResult
}


func partition(s string) [][]string {
    result := make([][]string, 0)
    _partition(s, &result)
    return result
}



func main(){
    data := "aabccb"
    fmt.Println(partition(data))
}
```
è¿è¡Œçš„è¾“å‡ºå¦‚ä¸‹
```
-> % go run testCode/main.go
firstStr a secondStr abccb
firstStr a secondStr bccb
firstStr b secondStr ccb
firstStr c secondStr cb
firstStr c secondStr b
tmp: [[b]]
tmp: [[c b]]
firstStr cc secondStr b
tmp: [[b]]
tmp: [[c c b] [cc b]]
tmp: [[b c c b] [b cc b] [bccb]]
tmp: [[a b c c b] [a b cc b] [a bccb]]
firstStr aa secondStr bccb
firstStr b secondStr ccb
firstStr c secondStr cb
firstStr c secondStr b
tmp: [[b]]
tmp: [[c b]]
firstStr cc secondStr b
tmp: [[b]]
tmp: [[c c b] [cc b]]
tmp: [[b c c b] [b cc b] [bccb]]
[]
```

åˆæ­¥çœ‹äº†ä¸€ä¸‹æ—¥å¿—ï¼Œæ„Ÿè§‰å¥½åƒtmpResultå°±æ˜¯æƒ³è¦çš„å•Šï¼Œæ­ªæ‰“æ­£ç€ï¼Œè€Œä¸”å®Œå…¨æ²¡ç”¨åˆ°resultè¿™ä¸ª

æ‰€ä»¥ä¿®æ”¹ä¸€ä¸‹ï¼ŒæŠŠæ²¡ç”¨çš„resultä¼ å‚ç»™å»äº†ï¼Œä»£ç å¦‚ä¸‹


### golangä»£ç 1

```go
func isPalindrome(s string) bool {
    if len(s) == 1{
        return true
    }
    l := 0
    r := len(s) - 1
    for l < r {
        if s[l] != s[r] {
            return false
        }
        l += 1
        r -= 1
    }
    return true
}

func partition(s string) [][]string {
    result := make([][]string, 0)
    // å›æ–‡çš„é•¿åº¦,ä»1åˆ°max
    for l := 1; l <= len(s); l ++ {
        // å·¦è¾¹è¿™ä¸ªå›æ–‡
        firstStr := s[0:l]
        if isPalindrome(firstStr) {
            secondStr := s[l:]
            if secondStr == ""{
                result = append(result, []string{firstStr})
                return result
            }
            // é€’å½’è°ƒç”¨ï¼Œé€’å½’å‡½æ•°è¿”å›çš„æ˜¯ä¸€ä¸ªäºŒç»´åˆ—è¡¨
            tmp := partition(secondStr)
            // tmpå¤§äº1è¯´æ˜secondStrè¿™ä¸ªé‡Œé¢ä¹Ÿæœ‰å›æ–‡å­—ç¬¦ä¸²
            // å°±å¯ä»¥æŠŠfirstStræ‹¼æ¥åˆ°ä»–ä»¬åˆ—è¡¨ç¬¬ä¸€ä¸ªçš„ä½ç½®
            if len(tmp) > 0{
                for i := range tmp {
                    tmpLevel := make([]string, 0)
                    tmpLevel = append(tmpLevel, firstStr)
                    tmpLevel = append(tmpLevel, tmp[i]...)
                    // ç„¶åå°±å¯ä»¥æŠŠè¿™ä¸ªæ‰©å±•è¿‡çš„åˆ—è¡¨è¿½åŠ åˆ°ç»“æœé‡Œé¢
                    result = append(result, tmpLevel)
                }
            }
        }
    }
    return result
}
```

è¿è¡Œç»“æœ
```
æ‰§è¡Œç”¨æ—¶åˆ†å¸ƒ
111ms å‡»è´¥5.05%

æ¶ˆè€—å†…å­˜åˆ†å¸ƒ
23.80MB å‡»è´¥70.41%
```

ç»è¿‡ä¸Šé¢è¿™ä¸ªæ€è·¯æµç¨‹ï¼Œå‘ç°é€’å½’çš„å¾ˆå¤šæ—¶å€™ï¼Œå¾ˆéš¾å»ç†æ¸…æ¥šé‡Œé¢å˜é‡çš„èµ‹å€¼æƒ…å†µï¼Œä½†æ˜¯æŠŠå¤–å±‚æ•´ä½“çš„é€»è¾‘ç†æ¸…æ¥šï¼Œæœ‰æ—¶å€™å°±æ˜¯æƒ³è¦çš„ç»“æœ

æ¯”å¦‚ä¸Šé¢å¾ˆæ¸…æ¥šè¦ç”¨åˆ°é€’å½’ï¼Œä½†æ˜¯å°±æ˜¯æä¸æ‡‚é€’å½’çš„æ—¶å€™é‡Œé¢çš„äºŒç»´åˆ—è¡¨è¦æ€ä¹ˆèµ‹å€¼ï¼Œå…¶å®åšäº†è¿™ä¹ˆå¤šé€’å½’é¢˜æ¥è¯´ï¼Œå¾€å¾€æœ€å…³é”®çš„ä¸€æ­¥å°±æ˜¯ç»ˆæ­¢æ¡ä»¶çš„èµ‹å€¼

å¤ä¹ ä¸€ä¸‹[é€’å½’è§£é¢˜æ€è·¯](../ç®—æ³•æ€»ç»“/é€’å½’è§£é¢˜æ€è·¯.md)

æ ¹æ®é¢˜ç›®æ¥è¯´å¯¹åº”çš„è§£é¢˜ä¸‰éƒ¨æ›²å¦‚ä¸‹

1. **é€’å½’ç»ˆæ­¢æ¡ä»¶ï¼šé€’å½’åº”è¯¥åœ¨ä»€ä¹ˆæ—¶å€™ç»“æŸï¼Ÿ**

ä»€ä¹ˆæ—¶å€™ç»“æŸå‘¢ï¼Ÿå°±æ˜¯ä¸Šé¢çš„`secondStr == ""`çš„æ—¶å€™,è¯´æ˜å·²ç»ç§»åŠ¨åˆ°æœ€å³è¾¹äº†

2. **æœ¬æ¬¡é€’å½’åšä»€ä¹ˆæ“ä½œï¼šåœ¨è¿™ä¸€çº§é€’å½’ä¸­ï¼Œåº”è¯¥å®Œæˆä»€ä¹ˆä»»åŠ¡ï¼Ÿ**

åšå•¥æ“ä½œå‘¢ï¼Ÿå°±æ˜¯æŠŠé€’å½’å‡½æ•°è¿”å›ç»™ä½ çš„äºŒç»´åˆ—è¡¨ï¼Œç»“åˆfirstStrï¼Œä¹Ÿå°±æ˜¯ä¸Šé¢çš„`len(tmp) > 0`ä¸‹é¢çš„æ“ä½œ

3. **è¿”å›ä»€ä¹ˆï¼šåº”è¯¥ç»™ä¸Šä¸€çº§è¿”å›ä»€ä¹ˆä¿¡æ¯ï¼Ÿ**

è¿”å›å•¥å‘¢ï¼Ÿå½“ç„¶å°±æ˜¯æŠŠæ­¥éª¤2çš„æ“ä½œè¿”å›å°±è¡Œ


### pythonä»£ç 1

æ ¹æ®goä»£ç ç¿»è¯‘ä¸ºpythonï¼Œå¤ªä¹…æ²¡ç”¨pythonï¼Œè€æ˜¯å¿˜è®°forå¾ªç¯çš„eachæ˜¯å€¼ï¼Œä¸æ˜¯ä¸‹æ ‡

```python
class Solution:        
    def isPalindrome(self, s: str) -> bool:
        if len(s) == 1:
            return True
        l, r = 0, len(s)-1
        while l < r:
            if s[l] != s[r]:
                return False
            l += 1
            r -= 1
        return True
    def partition(self, s: str) -> List[List[str]]:
        result = []
        # range(å¼€å§‹ï¼Œç»“æŸï¼Œæ­¥é•¿) è¿™é‡Œçš„ç»“æŸä¸åŒ…å«ï¼Œæ˜¯å·¦é—­å³å¼€
        for l in range(1, len(s)+1):
            first_str = s[0:l]
            if self.isPalindrome(first_str):
                second_str = s[l:]
                if second_str == "":
                    result.append([first_str])
                    return result
                tmp = self.partition(second_str)
                if tmp:
                    # ä¸åŒäºgoçš„for i := range tmpï¼šiæ˜¯ä¸‹æ ‡ï¼Œè¿™é‡Œitemæ˜¯å€¼
                    # eq for i in range(len(tmp))
                    for item in tmp:
                        tmp_level = [first_str]
                        tmp_level.extend(item)
                        result.append(tmp_level)
        return result
```

è¿è¡Œç»“æœ
```
æ‰§è¡Œç”¨æ—¶åˆ†å¸ƒ
115ms å‡»è´¥5.29%

æ¶ˆè€—å†…å­˜åˆ†å¸ƒ
33.18MB å‡»è´¥83.91%
```


## è§£æ³•2 å›æº¯:

è§£æ³•1æ˜¯ç”¨äº†é€’å½’çš„æ–¹å¼å»è§£é¢˜ï¼Œä¹Ÿå¯ä»¥ç”¨å›æº¯çš„æ€è·¯ï¼ˆå›æº¯æœ¬è´¨ä¸Šä¹Ÿæ˜¯é€’å½’ï¼‰

ä¹‹å‰é€’å½’æœ‰äº†æ•™è®­ï¼Œå…ˆçœ‹ä¸€ä¸‹[å›æº¯è§£é¢˜æ€è·¯](../ç®—æ³•æ€»ç»“/å›æº¯è§£é¢˜æ€è·¯.md)

ä¸‹é¢å°±ç”¨å¥—å…¬å¼çš„æ–¹æ³•ï¼Œä½¿ç”¨å›æº¯ç®—æ³•è§£é¢˜

### golangä»£ç 1
```go
func isPalindrome(s string) bool {
    if len(s) == 1{
        return true
    }
    l := 0
    r := len(s) - 1
    for l < r {
        if s[l] != s[r] {
            return false
        }
        l += 1
        r -= 1
    }
    return true
}

func backtrack(s string, lResult *[]string, tResult *[][]string){
    // å…¬å¼ï¼šif æ»¡è¶³ç»“æŸæ¡ä»¶:
    // å½“sä¸ºç©ºï¼Œè¯´æ˜åˆ†å‰²å®Œäº†
    if len(s) == 0{
        // å…¬å¼ï¼šresult.add(è·¯å¾„)
        // æŠŠè¿™ä¸€å±‚çš„ç»“æ„éƒ½addåˆ°æœ€ç»ˆç­”æ¡ˆé‡Œé¢
        // âš ï¸ï¼šè¿™é‡Œä¸€å®šè¦copyä¸€ä»½ï¼Œä¸ç„¶å›æº¯çš„æ—¶å€™lResultéƒ½ä¹±äº†
        // è¿™æ ·å†™*tResult = append(*tResult, *lResult)ä¼šå‘ç°æ˜æ˜lResultæ‰“å°å‡ºæ¥éƒ½æ˜¯å¯¹çš„
        // ä¸ºå•¥tResultå°±ä¹±äº†ï¼Œå› ä¸ºè¿™é‡ŒæŠŠåœ°å€ç»™è¿›å»äº†ï¼Œåé¢å›æº¯æ—¶å€™çš„popæ“ä½œå°±ä¼šå½±å“ä¹‹å‰å·²ç»appendçš„ç»“æœ
        // æ­£ç¡®çš„å¦‚ä¸‹
        copyLevelResult := make([]string, len(*lResult))
        copy(copyLevelResult, *lResult)
        *tResult = append(*tResult, copyLevelResult)
        // å…¬å¼ï¼šreturn
        return
    }
    // å…¬å¼ï¼šfor é€‰æ‹© in é€‰æ‹©åˆ—è¡¨:
    // å½“æˆç¬¬ä¸€æ¬¡å¾ªç¯ï¼Œæ€ä¹ˆé€‰æ‹©å‘¢ï¼Œå½“ç„¶å°±æ˜¯æ ¹æ®é•¿åº¦ä¾æ¬¡å»å°è¯•
    for l := 1; l <= len(s); l ++ {
        firstStr := s[0:l]
        if isPalindrome(firstStr){
            // å…¬å¼ï¼šåšé€‰æ‹©
            *lResult = append(*lResult, firstStr)
            // å…¬å¼ï¼šbacktrack(è·¯å¾„, æ–°çš„é€‰æ‹©åˆ—è¡¨)
            backtrack(s[l:], lResult, tResult)
            // å…¬å¼ï¼šæ’¤é”€é€‰æ‹©
            *lResult = (*lResult)[0:len(*lResult)-1]
        }
    }
}

func partition(s string) [][]string {
    // æ•´ä½“çš„ç­”æ¡ˆ
    total_result := make([][]string, 0)
    // æ¯å±‚çš„ç­”æ¡ˆï¼Œç”¨äºå›æº¯
    level_result := make([]string, 0)
    backtrack(s, &level_result, &total_result)
    return total_result
}
```
è¿è¡Œç»“æœ
```
æ‰§è¡Œç”¨æ—¶åˆ†å¸ƒ
10ms å‡»è´¥96.75%

æ¶ˆè€—å†…å­˜åˆ†å¸ƒ
24.61MB å‡»è´¥46.16%
```

å¦‚æœè§‰å¾—backtrackä¼ å‚æœ‰ç‚¹å¤šï¼Œå¯ä»¥ç”¨å†…ç½®å‡½æ•°ï¼ˆpythonä¸­çš„é—­åŒ…ï¼‰çš„æ–¹å¼æ¥

### pythonä»£ç 1

è€æ ·å­æŠŠgoç¿»è¯‘ä¸ºpythonï¼Œå¹¶ä¸”ä½¿ç”¨é—­åŒ…çš„æ–¹å¼

```python
class Solution:        
    def isPalindrome(self, s: str) -> bool:
        if len(s) == 1:
            return True
        l, r = 0, len(s)-1
        while l < r:
            if s[l] != s[r]:
                return False
            l += 1
            r -= 1
        return True
    def partition(self, s: str) -> List[List[str]]:
        result = []
        level_result = []
        def backtrack(s:str):
            if not s:
                # æ‹·è´ä¸€ä»½ï¼ˆè¿™é‡Œç”¨æµ…æ‹·è´ï¼Œgoé‚£ä¸ªcopyä¹Ÿæ˜¯æµ…æ‹·è´ï¼Œä¸è¿‡è¿™é‡Œå¤Ÿç”¨äº†ï¼‰
                result.append(level_result.copy())
                return
            for l in range(1, len(s)+1):
                first_str = s[:l]
                second_str = s[l:]
                if self.isPalindrome(first_str):
                    level_result.append(first_str)
                    backtrack(second_str)
                    level_result.pop()
        backtrack(s)
        return result
```
è¿è¡Œç»“æœ
```
æ‰§è¡Œç”¨æ—¶åˆ†å¸ƒ
51ms å‡»è´¥63.31%

æ¶ˆè€—å†…å­˜åˆ†å¸ƒ
33.38MB å‡»è´¥82.87%
```


æ¬¢è¿æ¥githubä¸Šçœ‹æ›´å¤šé¢˜ç›®çš„è§£ç­”[åŠ›æ‰£è§£é¢˜æ€è·¯](https://github.com/WRAllen/LeetCode)
