# 题目[28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)

实现 strStr() 函数。

给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。

示例 1:

```
输入: haystack = "hello", needle = "ll"
输出: 2
```

示例 2:

```
输入: haystack = "aaaaa", needle = "bba"
输出: -1
```

说明:

当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。

*****

# python解题思路

这题，不知道可不可以用字符串的index额姑且一试

```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        if needle == "": return 0
        if needle not in haystack: return -1
        return haystack.index(needle)
```

运行结果

```
执行用时 :24 ms, 在所有 python3 提交中击败了99.68% 的用户
内存消耗 :12.8 MB, 在所有 python3 提交中击败了99.53%的用户

执行用时 :28 ms, 在所有 python3 提交中击败了98.52% 的用户
内存消耗 :12.8 MB, 在所有 python3 提交中击败了99.47%的用户

执行用时 :36 ms, 在所有 python3 提交中击败了90.03% 的用户
内存消耗 :12.8 MB, 在所有 python3 提交中击败了99.47%的用户
```

其实如果是用内置函数的话有个更匹配的函数find

```python
class Solution:
    def strStr(self, haystack: str, needle: str) -> int:
        return haystack.find(needle)
```

同样符合题目要求， needle 为 空 返回0 needle 找不到就返回 -1

但是题目显然不是想让我们调用内置函数，于是下面开启字符串查找的学习之旅---字符匹配算法

### KMP算法

具体什么事KMP算法我这里就不解释了，推荐几个大佬写的博客

对kmp算法的[漫画解释](http://www.sohu.com/a/336648975_453160) 非常的有意思

还有一篇对kmp的解释[阮一峰的字符串匹配的KMP算法](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)也写的非常好

好了，下面就当大家都会KMP算法的思路了，具体的代码下面做出构建

下面是构建 PMT (也看到博客里面经常有人叫做next数组)的代码

```python
# 下面这个构建PMT的代码好像是祖传代码，开始我还疑惑为啥nex[0] = -1,后面自己解答后才发现是方便判断，后面会做解释
# p 是 子字符串
def getNext(self, p):
    nex = [0] * len(p)
    nex[0] = -1
    i = 0
    j = -1
    while i < len(p) - 1:
        if j == -1 or p[i] == p[j]:
            i += 1
            j += 1
            nex[i] = j 
        else:
            j = nex[j]
    return nex
```

看完这个祖传代码我是一头雾水，于是我用麻烦一点的方法构建了这个 PMT

原理就是按照构建PMT的方式来的，逐一比较前缀和后缀取出对应得最长重复长度

```python
def getNextBySelf(self, needle):
    list_length = len(needle)
    # 先创建了一个全是0的PMT
    next = [0] * list_length
    # 循环获取对应得字符串 例如 ABCDABD
    for i in range(list_length):
        # 当 i = 0 的时候 check_list = []
        # 当 i = 1 的时候 check_list = "A"
        # 当 i = 2 的时候 check_list = "AB"
        # 以此类推
        check_list = needle[0:i+1]
        # 获取 check_list 的前缀集合 
        # 例如check_list = "AB" 时 获取 "A"
        bef_list = set(check_list[0:i+1] for i in range(len(check_list)-1))
        # 获取 check_list 的后缀集合 
        aft_list = set(check_list[1+i:] for i in range(len(check_list)-1))
        # 取集合的交集
        # 例如 前缀{"A", "AB"} 后缀{"B", "AB"} 就取"AB"
        int_list = list(bef_list.intersection(aft_list))
        # 把交集里面最大的长度赋予next数组
        # 例如 ["A", "AB"] 就取"AB"的长 2
        next[i] = len(max(int_list)) if int_list else 0
    # 上面介绍的首位添加-1， 和右移next数组
    next.insert(0, -1)
    next.pop()
    return next
```

下面就是对应得解答

```python
class Solution:
    # 判断主体函数
    def strStr(self, haystack: str, needle: str) -> int:
        # 如果不含子字符串就直接返回-1
        if needle not in haystack: return -1
        if not needle: return 0
        nexts = self.getNextBySelf(needle)
        hays_index = 0
        next_index = 0 
        # 单两个指针都小于列表长度时循环
        while hays_index < len(haystack) and next_index < len(needle):
            # 只有第一次 或者是 两个字符串的字符相等 才会往后走
            if next_index == -1 or haystack[hays_index] == needle[next_index]:
                hays_index += 1
                next_index += 1
            # 如果不相等 就调用next数组的值进行next_index的回滚
            else: next_index = nexts[next_index]
        # 因为要求返回匹配到的开始下标，所以有了下面的判断
        if next_index == len(needle): return hays_index - next_index
        return -1
    
	# 上面介绍的获取next数组函数
    def getNextBySelf(self, needle):
        list_length = len(needle)
        next = [0] * list_length
        for i in range(list_length):
            # 这里可以写成一句，但是太长了又难理解，还是放弃
            check_list = needle[0:i+1]
            bef_list = set(check_list[0:i+1] for i in range(len(check_list)-1))
            aft_list = set(check_list[1+i:] for i in range(len(check_list)-1))
            int_list = list(bef_list.intersection(aft_list))
            next[i] = len(max(int_list)) if int_list else 0
        next.insert(0, -1)
        next.pop()
        return next
```

运行结果

```
执行用时 :24 ms, 在所有 python3 提交中击败了99.68% 的用户
内存消耗 :12.7 MB, 在所有 python3 提交中击败了99.53%的用户

执行用时 :32 ms, 在所有 python3 提交中击败了95.43% 的用户
内存消耗 :12.7 MB, 在所有 python3 提交中击败了99.53%的用户

执行用时 :32 ms, 在所有 python3 提交中击败了95.43% 的用户
内存消耗 :12.8 MB, 在所有 python3 提交中击败了99.53%的用户
```

像复杂逻辑的代码向来我是不喜欢太pythonic的，让人看了会一头雾水，后期自己回顾起来的时候也会气的想打自己

欢迎来github上看更多题目的解答[力扣解题思路](https://github.com/WRAllen/LeetCode)