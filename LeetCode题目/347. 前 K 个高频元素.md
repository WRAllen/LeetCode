# é¢˜ç›®[347. å‰ K ä¸ªé«˜é¢‘å…ƒç´ ](https://leetcode.cn/problems/top-k-frequent-elements/description/?envType=study-plan-v2&envId=top-100-liked)

ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums å’Œä¸€ä¸ªæ•´æ•° k ï¼Œè¯·ä½ è¿”å›å…¶ä¸­å‡ºç°é¢‘ç‡å‰ k é«˜çš„å…ƒç´ ã€‚ä½ å¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›ç­”æ¡ˆã€‚

 

ç¤ºä¾‹ 1ï¼š

    è¾“å…¥ï¼šnums = [1,1,1,2,2,3], k = 2

    è¾“å‡ºï¼š[1,2]

ç¤ºä¾‹ 2ï¼š

    è¾“å…¥ï¼šnums = [1], k = 1

    è¾“å‡ºï¼š[1]

ç¤ºä¾‹ 3ï¼š

    è¾“å…¥ï¼šnums = [1,2,1,2,1,2,3,1,3,2], k = 2

    è¾“å‡ºï¼š[1,2]

 

æç¤ºï¼š

    1 <= nums.length <= 105
    -104 <= nums[i] <= 104
    k çš„å–å€¼èŒƒå›´æ˜¯ [1, æ•°ç»„ä¸­ä¸ç›¸åŒçš„å…ƒç´ çš„ä¸ªæ•°]
    é¢˜ç›®æ•°æ®ä¿è¯ç­”æ¡ˆå”¯ä¸€ï¼Œæ¢å¥è¯è¯´ï¼Œæ•°ç»„ä¸­å‰ k ä¸ªé«˜é¢‘å…ƒç´ çš„é›†åˆæ˜¯å”¯ä¸€çš„
 

è¿›é˜¶ï¼šä½ æ‰€è®¾è®¡ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ å¿…é¡» ä¼˜äº O(n log n) ï¼Œå…¶ä¸­ n æ˜¯æ•°ç»„å¤§å°ã€‚

*****

# è§£é¢˜æ€è·¯

é¢˜ç›®è¯´çš„æ¯”è¾ƒæ¸…æ¥šäº†ï¼Œè¿”å›æ•°é‡æœ€å¤šçš„å‰kä¸ªæ•°æ®ã€‚

## è§£æ³•1 å­—å…¸+å•è°ƒé˜Ÿåˆ—:

ç¬¬ä¸€ä¸ªæƒ³æ³•å°±æ˜¯éå†ä¸€éæ•°ç»„ï¼Œç„¶åç”¨ä¸€ä¸ªå­—å…¸ï¼Œkeyæ˜¯å€¼ï¼Œvalueæ˜¯å‡ºç°æ¬¡æ•°ã€‚

ç„¶åéå†ä¸€ä¸‹è¿™ä¸ªmapï¼Œæ ¹æ®valueçš„å¤§å°ï¼Œç»´æŠ¤ä¸€ä¸ªé€’å¢/é€’å‡çš„æ•°ç»„ã€‚

è¿™é‡Œç»´æŠ¤ä¸€ä¸ªé€’å‡æ•°ç»„

### golangä»£ç 

```go
// è¿™é‡Œä¸‹é¢ç›´æ¥ç”¨tupleä¹Ÿè¡Œ
type MapInfo struct{
    key int
    num int
}

func topKFrequent(nums []int, k int) []int {
    info := make(map[int]int, 0)
    for i := range nums{
        info[nums[i]]++ 
    }
    // å•è°ƒé€’å‡æ•°ç»„
    mapInfoList := make([]MapInfo, 0)
    for key, value := range info{
        if len(mapInfoList) == 0 {
            mapInfoList = append(mapInfoList, MapInfo{key: key, num: value})
        } else {
            // ç”¨æ¥æ¥æ”¶popå‡ºæ¥çš„æ•°æ®
            tmp := make([]MapInfo, 0)
            for {
                if len(mapInfoList) == 0 {
                    break
                }
                // è·å–æ•°ç»„æœ€å°å€¼
                last := mapInfoList[len(mapInfoList)-1]
                // å¦‚æœæœ€å°å€¼éƒ½æ¯”å½“å‰çš„æ•°æ®å¤§ï¼Œé‚£ç›´æ¥æŠŠå½“å‰æ•°æ®è¿½åŠ åˆ°æœ«å°¾
                if last.num >= value {
                    mapInfoList = append(mapInfoList, MapInfo{key: key, num:value})
                    break
                } else {
                    // popæ“ä½œ
                    mapInfoList = mapInfoList[:len(mapInfoList)-1]
                    // æ¥æ”¶popå‡ºæ¥çš„å€¼
                    tmp = append(tmp, last)
                    // è¯´æ˜mapInfoListä¸ºç©ºï¼Œå½“å‰è¿™ä¸ªkeyï¼Œvalueæ˜¯æœ€å¤§çš„
                    if len(mapInfoList) == 0 {
                        mapInfoList = append(mapInfoList, MapInfo{key: key, num:value})
                        break
                    }
                }
            }
            // åˆ°è¿™é‡ŒmapListçš„å•è°ƒæ€§ç»´æŒå¥½äº†ï¼Œéœ€è¦æŠŠä¹‹å‰popè°ƒçš„æ·»åŠ å›æ¥
            // ç”±äºä¹‹å‰æ˜¯ [å¤§ï¼Œå°] çš„mapListï¼Œåœ¨tmpé‡Œé¢å°±æ˜¯[å°ï¼Œ å¤§]
            // æ‰€ä»¥ç›´æ¥pop tmpåˆ°mapListå°±è¿˜åŸäº†å•è°ƒæ€§äº†
            for len(tmp) > 0 {
                tmpLast := tmp[len(tmp)-1]
                tmp = tmp[:len(tmp)-1]
                mapInfoList = append(mapInfoList, tmpLast)
            }
        }
    }
    result := make([]int, k)
    for i := 0; i < k; i ++ {
        result[i] = mapInfoList[i].key
    }
    return result
}
```

è¿è¡Œç»“æœ
```
æ‰§è¡Œç”¨æ—¶åˆ†å¸ƒ
15ms å‡»è´¥5.95%

æ¶ˆè€—å†…å­˜åˆ†å¸ƒ
9.50MB å‡»è´¥5.02%
```

å“‡å“¦ï¼Œè¿™ä¸ªå‡»è´¥ç™¾åˆ†æ¯”å¥½ä½å“¦ :D


### pythonä»£ç 

pythonè¿™é‡Œæˆ‘ç›´æ¥è°ƒç”¨ç¥ç§˜åŠ›é‡ï¼ˆsortå‡½æ•°+lambdaè¡¨è¾¾å¼ï¼‰

```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        info = {}
        for i in range(len(nums)):
            if nums[i] in info:
                info[nums[i]] += 1
            else:
                info[nums[i]] = 1
        # æ˜¯ä¸€ä¸ªå…ƒç»„åˆ—è¡¨ [(æ•°å€¼ï¼Œå‡ºç°æ¬¡æ•°)]
        info_list = []
        for key, v in info.items():
            info_list.append((key, v))
        # æ ¹æ®xçš„ç¬¬äºŒä½å€’å™æ’ï¼Œä¹Ÿå°±æ˜¯å‡ºç°æ¬¡æ•°
        info_list.sort(key=lambda x: -x[1])
        result = []
        for i in range(k):
            result.append(info_list[i][0])
        return result
```

è¿è¡Œç»“æœ
```
æ‰§è¡Œç”¨æ—¶åˆ†å¸ƒ
4ms å‡»è´¥59.42%

æ¶ˆè€—å†…å­˜åˆ†å¸ƒ
20.31MB å‡»è´¥95.64%
```

### rustä»£ç 

æ¥å•¦rustï½

```rust
use std::collections::HashMap;
impl Solution {
    pub fn top_k_frequent(nums: Vec<i32>, k: i32) -> Vec<i32> {
        let mut info = HashMap::new();
        for num in &nums{
            // or_insert è¿”å›çš„æ˜¯ä¸€ä¸ªå¼•ç”¨ï¼Œæ‰€ä»¥è¦*è§£å¼•ç”¨
            *info.entry(num).or_insert(0) += 1;
        }
        let mut info_list = Vec::new();
        for (key, value) in info{
            info_list.push((key, value));
        }
        // ç”¨cmpå¦‚ä¸‹
        // info_list.sort_by(|a, b| b.1.cmp(&a.1));
        info_list.sort_by_key(|x| -x.1);
        // ä¸‹é¢è¿™ç§ä¹Ÿè¡Œ
        // use std::cmp::Reverse;
        // info_list.sort_by_key(|x| Reverse(x.1));
        let mut result: Vec<i32> = Vec::new();
        // è¿™é‡Œå¶é‡vecé‡Œé¢çš„ä¸‹æ ‡è¦usizeçš„
        for i in 0..k as usize{
            result.push(info_list[i].0.clone());
        }
        result
    }
}
```

è¿è¡Œç»“æœ
```
æ‰§è¡Œç”¨æ—¶åˆ†å¸ƒ
0ms å‡»è´¥100.00%

æ¶ˆè€—å†…å­˜åˆ†å¸ƒ
2.41MB å‡»è´¥93.62%
```

## è§£æ³•2 æ¡¶æ’åº

æ„Ÿè§‰åº”è¯¥æ˜¯æˆ‘å†™çš„å•è°ƒé˜Ÿåˆ—åƒäº†ï¼Œä¸€ä¸‹å­åˆæƒ³ä¸èµ·æ¥å„ç§æ’åºï¼Œå·å·çœ‹äº†å®˜æ–¹çš„è§£ç­”ï¼Œå‘ç°ç¬¬ä¸€ç§è§£æ³•ç”¨å †ï¼Œç¬¬äºŒç§è§£æ³•ç”¨å¿«æ’ã€‚

å†™å †æ˜¯ä¸å¯èƒ½å†™å †çš„ï¼Œè¿™è¾ˆå­é¢è¯•çš„æ—¶å€™æ˜¯ä¸å¯èƒ½å†™å †çš„ï¼Œé¢è¯•çš„æ—¶å€™è°è¿˜è®°å¾—æœ€å¤§/å°å †çš„é‚£äº›å®šä¹‰ğŸ˜“

è¯•äº†ä¸€ä¸‹å¿«æ’ï¼Œæ„Ÿè§‰è™½ç„¶å¿«äº†ä¸€ç‚¹ï¼Œä½†æ˜¯æµç¨‹ä¹Ÿæ˜¯éå¸¸å¤æ‚çš„ï¼Œè¿™é‡Œçœ‹åˆ°ä¸€ä¸ªå¤§ç¥çš„[è§£ç­”](https://leetcode.cn/problems/top-k-frequent-elements/solutions/3655287/tong-pai-xu-on-xian-xing-zuo-fa-pythonja-oqq2/?envType=study-plan-v2&envId=top-100-liked)

çªç„¶æ˜ç™½äº†ï¼Œç®€å•è¯´å°±æ˜¯å‡†å¤‡ä¸€äº›æ•°ç»„ï¼ˆåˆ—è¡¨ï¼‰ï¼Œç”¨äºå­˜å‚¨é‡å¤å‡ºç°æ¬¡æ•°ç›¸åŒçš„æ•°æ®ï¼ˆå› ä¸ºé¢˜ç›®è¯´é¡ºåºæ²¡æœ‰å…³ç³»ï¼Œæ‰€ä»¥è¿™é‡Œåªç®¡å¾€æ•°ç»„é‡Œé¢æ”¾å°±è¡Œï¼‰

ç„¶åæˆ‘è§‰å¾—æœ€ç²¾å¦™çš„åœ°æ–¹æ¥äº†ï¼Œæ€ä¹ˆæ”¾è¿™äº›æ•°ç»„å‘¢ï¼ˆå› ä¸ºè¦ä»é‡å¤æ¬¡æ•°æœ€å¤šé‚£ä¸ªå¼€å§‹æ’ï¼‰ï¼Œå…¶å®ä¹Ÿæ˜¯ä¸€ä¸ªæ•°ç»„ï¼ˆäºŒç»´æ•°ç»„ï¼‰ï¼Œè¿™ä¸ªæ•°ç»„çš„é•¿åº¦ä¸ºå­—å…¸é‡Œé¢ç»Ÿè®¡æœ€å¤§çš„æ•°æ®+1

æ¯”å¦‚å­—å…¸é‡Œé¢1é‡å¤äº†5æ¬¡ï¼Œé‚£è¿™ä¸ªæ•°ç»„çš„é•¿åº¦å°±æ˜¯6ï¼ˆè¿™æ ·æ–¹ä¾¿å–ï¼Œ0è¿™ä¸ªä¸ç”¨ï¼Œå¥½åƒä¹Ÿæ˜¯æ¡¶æ’åºçš„æ ‡å‡†å†™æ³•ï¼Ÿè¿™é‡Œä¸æ‡‚ï¼Œåç»­æ¥è§¦äº†å†è¯´ï¼‰

ç„¶åæ ¹æ®å­—å…¸é‡Œé¢çš„valueï¼Œä¹Ÿå°±æ˜¯é‡å¤æ¬¡æ•°ï¼ŒæŠŠæ•°æ®æ”¾åˆ°è¿™ä¸ªæ•°ç»„é‡Œé¢ï¼Œè¿™æ ·è‡ªç„¶å°±åšå¥½äº†æ’åºäº†ï¼Œå–å€¼æ—¶ï¼Œä»åå¾€å‰å–å°±è¡Œ

### goä»£ç 

```go
func topKFrequent(nums []int, k int) []int {
    info := make(map[int]int, 0)
    // ç»Ÿè®¡é‡å¤æ¬¡æ•°æœ€å¤šçš„æ•°æ®
    maxNum := 0
    for i := range nums{
        info[nums[i]]++ 
        maxNum = max(maxNum, info[nums[i]])
    }
    // è¿™æ ·å°±åˆå§‹åŒ–å¥½äº†maxNum+1ä¸ªä¸€çº¬æ•°ç»„
    // è¿™é‡Œä¸ç”¨maxNum+1 åç»­ä¸‹é¢çš„valueéƒ½è¦-1äº†ï¼Œæ‰€ä»¥è¿˜æ˜¯+1æ¯”è¾ƒæ–¹ä¾¿
    bucket := make([][]int, maxNum+1)
    for key, value := range info {
        bucket[value] = append(bucket[value], key)
    }
    // å€’åºéå†bucket
    // ç”±äºé¢˜ç›®è¯´ä¸€å®šå­˜åœ¨ç­”æ¡ˆï¼Œåªåˆ°resulté•¿åº¦æ­£å¥½ç­‰äºkå°±å¯ä»¥ç»“æŸäº†
    result := make([]int, 0)
    // å¦‚æœé¢˜ç›®æ²¡è¯´ä¸€å®šæœ‰å€¼ï¼Œforè¦æ”¹æˆfor i := maxNum; i >= 0 && len(result) < k; i--{
    for i := maxNum; len(result) < k; i--{
        // æŠŠè¿™ä¸ªé‡å¤æ¬¡æ•°çš„ä¸€ç»´åˆ—è¡¨é‡Œé¢çš„æ•°æ®éƒ½åŠ å…¥resultï¼ˆå› ä¸ºé‡å¤æ¬¡æ•°ç›¸åŒçš„æ•°æ®å¯èƒ½æœ‰å¥½å¤šä¸ªï¼‰
        result = append(result, bucket[i]...)
    }
    return result
}

func max(a, b int) int {
    if a >= b {
        return a
    }
    return b
}
```

è¿è¡Œç»“æœ
```
æ‰§è¡Œç”¨æ—¶åˆ†å¸ƒ
3ms å‡»è´¥49.34%

æ¶ˆè€—å†…å­˜åˆ†å¸ƒ
7.40MB å‡»è´¥68.21%
```


### pythonä»£ç 

```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        info = {}
        max_num = 0
        for i in range(len(nums)):
            if nums[i] in info:
                info[nums[i]] += 1
            else:
                info[nums[i]] = 1
            max_num = max(max_num, info[nums[i]])
        bucket = [[] for _ in range(max_num+1)] 
        for key, value in info.items():
            bucket[value].append(key) 
        result = []
        for each in bucket[::-1]:
            if len(result) == k:
                break
            result.extend(each)
        return result
```

è¿è¡Œç»“æœ
```
æ‰§è¡Œç”¨æ—¶åˆ†å¸ƒ
11ms å‡»è´¥15.97%

æ¶ˆè€—å†…å­˜åˆ†å¸ƒ
20.25MB å‡»è´¥97.44%
```

### rustä»£ç 

ç¿»è¯‘ä¸ºrust

```rust
use std::collections::HashMap;
impl Solution {
    pub fn top_k_frequent(nums: Vec<i32>, k: i32) -> Vec<i32> {
        let mut info = HashMap::new();
        // è¿™é‡Œinfoçš„ç±»å‹ï¼Œä¹‹å‰keyæ˜¯&i32ï¼Œè¿™é‡Œæ”¹ä¸ºi32
        // rustè¿™å—æ˜¯çœŸçš„éš¾ï¼Œå¯¹æ–°æ‰‹ä¸æ˜¯å¾ˆå‹å¥½
        // å› ä¸ºå£°æ˜çš„ç±»å‹éƒ½æ²¡å†™ï¼Œè¿™é‡Œå¦‚æœä»£ç æ”¾åˆ°ideaé‡Œé¢æœ‰rust-analyzerå¸®å¿™è§£æå°±èƒ½çœ‹åˆ°æ¨å¯¼å‡ºæ¥çš„ç±»å‹äº†
        for &num in &nums{
            // ä¸Šé¢å¦‚æœæ˜¯numï¼Œè¿™é‡Œ*numè§£åº”ç”¨ä¹Ÿè¡Œ
            *info.entry(num).or_insert(0) += 1;
        }
        let max_num = info.values().max().unwrap();
        let mut bucket = vec![vec![]; max_num+1];
        for (key, value) in info{
            bucket[value].push(key);
        }
        let mut result: Vec<i32> = Vec::new();
        for each in bucket.iter().rev(){
            if result.len() == k as usize{
                break
            }
            result.extend(each.iter())
        }
        result
    }
}
```

è¿è¡Œç»“æœ
```
æ‰§è¡Œç”¨æ—¶åˆ†å¸ƒ
0ms å‡»è´¥100.00%

æ¶ˆè€—å†…å­˜åˆ†å¸ƒ
2.57MB å‡»è´¥46.81%
```

å“‡å“¦ï¼Œç”¨æ—¶å‡»è´¥äº†å…¨ä¸–ç•Œ[doge]ï¼Œrustç‰›é€¼

æ¬¢è¿æ¥githubä¸Šçœ‹æ›´å¤šé¢˜ç›®çš„è§£ç­”[åŠ›æ‰£è§£é¢˜æ€è·¯](https://github.com/WRAllen/LeetCode)
