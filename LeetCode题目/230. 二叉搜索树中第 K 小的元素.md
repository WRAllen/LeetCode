# 题目[230. 二叉搜索树中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/description/?envType=study-plan-v2&envId=top-100-liked)

给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 小的元素（从 1 开始计数）。

 

示例 1：


![1](https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg)

    输入：root = [3,1,4,null,2], k = 1  
    输出：1


示例 2：


![2](https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg)

    输入：root = [5,3,6,2,4,null,null,1], k = 3
    输出：3
 

提示：

    树中的节点数为 n 。
    1 <= k <= n <= 104
    0 <= Node.val <= 104
 

进阶：
    
    如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？


*****

# 解题思路

如果没遍历完所有的节点，就不知道倒数K小的数据是啥，比较你都不知道都有啥数据，怎么会知道哪些最小

所以一定要知道所有的数据，也就是一定会遍历一遍二叉搜索树(BST)

## 解法1-中序遍历:

求倒数第K个数据，如果二叉搜索树变成一个单调队列那获得其要的倒数第K个数据也就非常简单

树的遍历有前序，中序，后序遍历，区别在于什么时候读root的位置

那由于BST的 左节点 < root < 右节点 所以，先用中序遍历出结果，再取值

先回顾一下中序遍历
```go
// 中序遍历：Left → Root → Right
func inorderTraversal(root *TreeNode) []int {
    var res []int
    var dfs func(node *TreeNode)

    dfs = func(node *TreeNode) {
        if node == nil {
            return
        }
        dfs(node.Left)
        res = append(res, node.Val)
        dfs(node.Right)
    }

    dfs(root)
    return res
}
```

### golang代码1

所以结合中序遍历，后的递增列表，很容易就可以获取第K小的数据

```go
func kthSmallest(root *TreeNode, k int) int {
    result := make([]int, 0)
    // 虽然slice是引用传递，但是数里面做了append，变成一个新slice了，
    // 导致外面这里的result和函数里的不是同一个了，所以这里要传地址（数组也是值传递）
    inOrderTraversal(root, &result)
    fmt.Println("result:", result)
    // 第1小的值，其实是第0位的，这里-1
    return result[k-1]
}

func inOrderTraversal(root *TreeNode, result *[]int) {
    if root == nil {
        return
    }
    inOrderTraversal(root.Left, result)
    *result = append(*result, root.Val)
    inOrderTraversal(root.Right, result)
}

```

运行结果
```
执行用时分布
8ms 击败2.42%

消耗内存分布
8.25MB 击败81.67%
```

### python代码1

把go代码翻译为python，下面变量result和go的不一样，go由于slice的性质，要注意一下

```python
class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        result = []
        self.inOrderTraversal(root, result)
        return result[k-1]

    def inOrderTraversal(self, root, result):
        if root is None:
            return
        self.inOrderTraversal(root.left, result)
        result.append(root.val)
        self.inOrderTraversal(root.right, result)
```

运行结果
```
执行用时分布
3ms 击败43.75%

消耗内存分布
20.83MB 击败15.16%
```

## 解法2 记录子树的节点数:

看了一下官方的解法2，就个人感觉，想法确实挺惊艳的，核心就是每个node记录一下左子树的节点数量，然后用k和这个数量对比

举个例子，假如root左边有2个node，k为3，又因为他是二叉搜索树，那当前的root就正好是第三小（k-1）的元素

也是一种解题思路，但是他说如果要平凡查找第K小的值，这种方法算是优化，这里我感觉不出他哪里优化了，

list+index也能对应频繁的查找，这里我不太理解（如果他的意思是map存储了这些子节点的数据的话，那list直接存答案不是更好？）

不过不管了，多一种结局方法也是好的


### golang代码1

首先遍历一遍tree，统计一下各个node他子节点的数量，然后从root开始和k做判断，如果k大于root的左子树的节点数量，

那边说明k在右边，把root变成root.right，k变成k-左子树的数量，代码如下

```go
var info map[*TreeNode]int

func kthSmallest(root *TreeNode, k int) int {
    info = make(map[*TreeNode]int)
    countNodeNum(root)
    return find(root, k)
}

func find(root *TreeNode, k int) int {
    if root == nil {
        return 0
    }
    // 如果当前root左边等于k-1，那说明当前root就是第k小的，返回当前root的值
    // 比如：root的左边有2个，那找第3小的话，当前root就是第3小
    if info[root.Left] == k - 1{
        return root.Val
    // 如果左边的数量比k-1小，说明k在右边
    // 比如：root的左边有2个，找滴4小的话，左边肯定找不到，就找右边
    } else if info[root.Left] < k - 1 {
        // 找右边的时候，要去掉左边和当前的root
        return find(root.Right, k - info[root.Left] - 1)
    } else {
        return find(root.Left, k)
    }
}

func countNodeNum(root *TreeNode) int {
    if root == nil {
        return 0
    }
    info[root] = countNodeNum(root.Left) + countNodeNum(root.Right) + 1
    return info[root]
}
```

运行结果
```
执行用时分布
4ms 击败5.95%

消耗内存分布
8.91MB 击败58.65%
```

### python代码1

照例翻译成python

```python
class Solution:
    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:
        self.info = {}
        self.countNode(root)
        return self.find(root, k)
    
    def countNode(self, root):
        if root is None: 
            return 0
        self.info[root] = self.countNode(root.left) + self.countNode(root.right) + 1
        return self.info[root]
    
    # python和go不一样，go如果key不存在会有默认值，python的话是None
    def _getNodeNum(self, root):
        return self.info[root] if root in self.info else 0

    def find(self, root, k):
        if root is None:
            return 0
        if self._getNodeNum(root.left) == k - 1:
            return root.val
        if self._getNodeNum(root.left) < k - 1:
            return self.find(root.right, k - self._getNodeNum(root.left) - 1)
        else:
            return self.find(root.left, k)
```

运行结果
```
执行用时分布
4ms 击败22.28%

消耗内存分布
20.59MB 击败93.81%
```


欢迎来github上看更多题目的解答[力扣解题思路](https://github.com/WRAllen/LeetCode)
