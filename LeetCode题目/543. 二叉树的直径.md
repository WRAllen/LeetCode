# 题目[543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked)

给你一棵二叉树的根节点，返回该树的 直径 。

二叉树的 直径 是指树中任意两个节点之间最长路径的 长度 。这条路径可能经过也可能不经过根节点 root 。

两节点之间路径的 长度 由它们之间边数表示。

 

示例 1：

![1](https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg)

    输入：root = [1,2,3,4,5]
    输出：3
    解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。

示例 2：

    输入：root = [1,2]
    输出：1
 

提示：

    树中节点数目在范围 [1, 104] 内
    -100 <= Node.val <= 100

*****

# 解题思路

刚开始以为求树里面哪一层是最大的，认真看了一下，人家哪里是要你知道每层的最大数量，明明是要知道边的长度，又不看题（该打）

如果是最大层的数量可以参考[102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/description/)这题

## 解法1 递归-DFS遍历:

树就是天生的递归好手（滑稽），假如，我说假如，如果我知道当前node左边的最大，又知道右边的最大

那当前node的最大长度就是左边+右边，但是对于上一层，我就只能返回左边或者右边（这样才能和其他node链接）

### golang代码1

代码如下：

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

var maxlength int

func diameterOfBinaryTree(root *TreeNode) int {
    // 记录最大的直径
    maxlength = 0
    dfs(root)
    return maxlength
}

func dfs(root *TreeNode) int {
    if root == nil {
        return 0
    }
    if root.Left == nil && root.Right == nil {
        return 0
    }
    // 左边节点的最大值(注意这里是左节点的最大边，不是当前节点左边最大，下面的+1才是)
    leftMax := dfs(root.Left)
    rightMax := dfs(root.Right)
    tmpMax := leftMax + rightMax
    // 如果有左边节点有值，说明上面的leftMax需要+1，才是当前节点左边的最大直径
    // 不然只是leftNode的直径
    if root.Left != nil {
        tmpMax += 1
    }
    if root.Right != nil {
        tmpMax += 1
    }
    if tmpMax> maxlength {
        maxlength = tmpMax
    }
    // 同理，最大子节点+1才是当前这边的最大直径
    if leftMax > rightMax {
        return leftMax + 1
    }
    return rightMax + 1
}

```

运行结果
```
执行用时分布
0ms 击败100.00%

消耗内存分布
9.43MB 击败50.66%
```

### python代码1

把go的代码翻译成python如下

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
        self.result = 0
        def dfs(root) -> int:
            if root is None:
                return 0
            if root.left is None and root.right is None:
                return 0
            leftMax = dfs(root.left)
            rightMax = dfs(root.right)
            tmpMax = leftMax + rightMax
            if root.left is not None:
                tmpMax += 1
            if root.right is not None:
                tmpMax += 1
            self.result = max(self.result, tmpMax)
            return leftMax + 1 if leftMax > rightMax else rightMax + 1
        dfs(root)
        return self.result
        
```

运行结果
```
执行用时分布
3ms 击败94.88%

消耗内存分布
20.64MB 击败5.59%
```

欢迎来github上看更多题目的解答[力扣解题思路](https://github.com/WRAllen/LeetCode)
