# 题目[295. 数据流的中位数](https://leetcode.cn/problems/find-median-from-data-stream/description/?envType=study-plan-v2&envId=top-100-liked)

中位数是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。

例如 arr = [2,3,4] 的中位数是 3 。
例如 arr = [2,3] 的中位数是 (2 + 3) / 2 = 2.5 。
实现 MedianFinder 类:

MedianFinder() 初始化 MedianFinder 对象。

void addNum(int num) 将数据流中的整数 num 添加到数据结构中。

double findMedian() 返回到目前为止所有元素的中位数。与实际答案相差 10-5 以内的答案将被接受。

示例 1：

    输入
    ["MedianFinder", "addNum", "addNum", "findMedian", "addNum", "findMedian"]
    [[], [1], [2], [], [3], []]
    输出
    [null, null, null, 1.5, null, 2.0]

    解释
    MedianFinder medianFinder = new MedianFinder();
    medianFinder.addNum(1);    // arr = [1]
    medianFinder.addNum(2);    // arr = [1, 2]
    medianFinder.findMedian(); // 返回 1.5 ((1 + 2) / 2)
    medianFinder.addNum(3);    // arr[1, 2, 3]
    medianFinder.findMedian(); // return 2.0

提示:

    -105 <= num <= 105
    在调用 findMedian 之前，数据结构中至少有一个元素
    最多 5 * 104 次调用 addNum 和 findMedian

*****

# 解题思路

啊，看起来题目很简单啊，为啥是Hard级别呢? 不就是取中位数吗？ 哦吼，原来是要有序的啊！！！

比如[6， 10]， 这个时候再添加2，不是[6, 10, 2] 而是 [2, 6, 10]

## 解法1 单调队列:

那其实就是维护一个单调队列，然后取中间值就行,之前做过类似的一题 [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/description/?envType=study-plan-v2&envId=top-100-liked)


### golang代码

```go
type MedianFinder struct {
    // 单调递减
    data []int
}


func Constructor() MedianFinder {
    return MedianFinder{data: []int{}}
}


func (this *MedianFinder) AddNum(num int)  {
    if len(this.data) == 0 {
        this.data = append(this.data, num)
        return
    }
    tmp := make([]int, 0)
    for len(this.data) > 0 {
        lastNum := this.data[len(this.data)-1]
        if lastNum >= num {
            this.data = append(this.data, num)
            break
        } else {
            this.data = this.data[:len(this.data)-1]
            tmp = append(tmp, lastNum)
        }
    }
    // 说明num是最大的，把data都制空了
    if len(this.data) == 0 {
        this.data = append(this.data, num)
    }
    for len(tmp) > 0 {
        lastTmp := tmp[len(tmp)-1]
        tmp = tmp[:len(tmp)-1]
        this.data = append(this.data, lastTmp)
    }
}


func (this *MedianFinder) FindMedian() float64 {
    dataLen := len(this.data)
    if dataLen == 0 {
        return 0
    }
    middle := len(this.data) / 2
    if dataLen % 2 == 0 {
        middleValue := float64(this.data[middle -1] + this.data[middle]) / 2
        return float64(middleValue)
    }
    return float64(this.data[middle])
}  
```

运行结果
```
超出时间限制
21 / 22 个通过的测试用例
```

可恶啊，21号用例超级长，而且还是递增的！！！ 这样每次都会命中上面逻辑时间复杂度最久的case，

也就是每次添加一个一个数据，整个data的list都要挪一遍，不用说了，他肯定还有全是递减的case在20，或者22

所以上面的方法是行不通的

又要用到小顶堆，大顶堆（也是小顶堆，把push的数据取负数就是大顶堆了）下面代码死记硬背一下了

```go

import (
	"container/heap"
	"sort"
)

type hp struct{ sort.IntSlice }
func (h *hp) Push(v interface{}) { 
    h.IntSlice = append(h.IntSlice, v.(int)) 
}
func (h *hp) Pop() interface{}   {
     v := h.IntSlice[len(h.IntSlice)-1]
     h.IntSlice = h.IntSlice[:len(h.IntSlice)-1]
     return v 
}

// 后续使用
headp.Push(hp, 数据)

```

那这两个堆这么用呢，假设数据[1, 2, 3, 4, 5, 6]

把[1,2,3] 放入hp的时候，其实我们要一下次取到3，所以如果是正常的小顶堆，这里取的是1，所以我们把数据

变成[-1, -2, -3],那么-3就是最小的，他就在顶上

对于[4, 5, 6] 正常放入小顶堆，那4就在最上面，直接取，所以就是（3+4）/2


如果是奇数数据 [1, 2, 3, 4, 5]

左边的小顶堆这边保持比右边这边的小顶堆大1个，这样直接取左边这边的小顶堆的0就是想要的答案了，上面也就是3

代码如下
```go
// 下面代码套进去就行
// sort.IntSlice 帮我们实现了heap的大多数函数了，Push和Pop需要我们自己写一下
type hp struct{ sort.IntSlice }
func (h *hp) Push(v interface{}) { 
    h.IntSlice = append(h.IntSlice, v.(int)) 
}
func (h *hp) Pop() interface{}   {
     v := h.IntSlice[len(h.IntSlice)-1]
     h.IntSlice = h.IntSlice[:len(h.IntSlice)-1]
     return v 
}

// 一定类型要对，要是*hp，不然底下使用时会说没实现相关接口
type MedianFinder struct {
    leftHp  *hp
    rightHp *hp
}

// 初始化函数
func Constructor() MedianFinder {
    return MedianFinder{
        leftHp:  &hp{},
        rightHp: &hp{},
    }
}


func (this *MedianFinder) AddNum(num int)  {
    // 左边为空，直接Push后return
    if this.leftHp.Len() == 0 {
        heap.Push(this.leftHp, -num)
        return
    } 
    // 取左边最大的数据
    leftMax := -this.leftHp.IntSlice[0]
    // 如果num比左边最大的还大，就放入右边
    if num > leftMax {
        heap.Push(this.rightHp, num)
        // Len()方法 sort.IntSlice 里面实现了
        // 如果num加入右边后，右边比左边大了，那就把右边最小的移动到左边
        // 我们要保证左边和右边相等，或者左边比右边大1
        if this.rightHp.Len() > this.leftHp.Len() {
            // 右边pop调最小的那个 .(int) 断言转化为int型
            rightMin := heap.Pop(this.rightHp).(int)
            // 加入左边，由于左边都是负数，这里也取负数
            heap.Push(this.leftHp, -rightMin)
        }
    } else {
        // 比左边最大的小，还是放入左边
        heap.Push(this.leftHp, -num)
        // 但是为了维持奇数下，左边比右边大1个情况,多余的数据就要放入右边
        if this.leftHp.Len() > this.rightHp.Len() + 1{
            leftMax := heap.Pop(this.leftHp).(int)
            heap.Push(this.rightHp, -leftMax)
        }   
    }
}

func (this *MedianFinder) FindMedian() float64 {
    if this.leftHp.Len() == this.rightHp.Len() {
        leftMax := -this.leftHp.IntSlice[0]
        rightMin := this.rightHp.IntSlice[0]
        return (float64(leftMax) + float64(rightMin)) / 2
    }
    return float64(-this.leftHp.IntSlice[0])
}  
```

运行结果
```
执行用时分布
105ms 击败86.04%

消耗内存分布
25.09MB 击败23.86%
```

把最小顶的模版记下，以后妈妈再也不用怕我解有序列表的问题啦:D

使用时，要用heap.Push/heap.Pop哦


### python代码

对于python来说，head用heapq,也不需要去写接口实现，比go方便多了

```python
import heapq
class MedianFinder:

    def __init__(self):
        self.left_hp = []
        self.right_hp = []

    def addNum(self, num: int) -> None:
        if not self.left_hp:
            heapq.heappush(self.left_hp, -num)
            return
        if num > -self.left_hp[0]:
            heapq.heappush(self.right_hp, num)
            if len(self.right_hp) > len(self.left_hp):
                heapq.heappush(self.left_hp, -heapq.heappop(self.right_hp))
        else:
            heapq.heappush(self.left_hp, -num)
            if len(self.left_hp) > len(self.right_hp) + 1:
                heapq.heappush(self.right_hp, -heapq.heappop(self.left_hp))

    def findMedian(self) -> float:
        if len(self.left_hp) == len(self.right_hp):
            return (-self.left_hp[0] + self.right_hp[0]) / 2
        return -self.left_hp[0]
```

运行结果
```
执行用时分布
138ms 击败92.47%

消耗内存分布
41.45MB 击败5.00%
```

### rust代码

rust来喽，首先搜索一下最小堆，发现rust的支持很好
```rust
use std::cmp::Reverse;
use std::collections::BinaryHeap;

BinaryHeap<i32>          // 最大堆 默认是最大堆
BinaryHeap<Reverse<i32>> // 最小堆 里面用Reverse就是最小堆
```

具体代码如下：

```rust
use std::cmp::Reverse;
use std::collections::BinaryHeap;

struct MedianFinder {
    // BinaryHeap 最大堆
    left_hp: BinaryHeap<i32>,
    // 加上Reverse就是最小堆，这里和go以及python相反
    right_hp: BinaryHeap<Reverse<i32>>,
}

impl MedianFinder {

    fn new() -> Self {
        Self { left_hp: BinaryHeap::new(), right_hp: BinaryHeap::new() }
    }
    
    fn add_num(&mut self, num: i32) {
        if self.left_hp.is_empty(){
            self.left_hp.push(num);
            return
        }
        if num > *self.left_hp.peek().unwrap(){
            self.right_hp.push(Reverse(num));
            if self.right_hp.len() > self.left_hp.len(){
                // rust的模式匹配，这样right_min就是Reverse里面的值
                let Reverse(right_min) = self.right_hp.pop().unwrap();
                self.left_hp.push(right_min);
            }
        } else {
            self.left_hp.push(num);
            if self.left_hp.len() > self.right_hp.len() + 1{
                self.right_hp.push(Reverse(self.left_hp.pop().unwrap()));
            }
        }
    }
    
    fn find_median(&self) -> f64 {
        if self.left_hp.len() == self.right_hp.len(){
            // 因为peek出来是引用&，所以需要加上*接引用
            let left_max = *self.left_hp.peek().unwrap() as f64;
            // 下面这个也可以这样写  因为unwrap的结果是&Reverse<i32>， .0就直接取出i32
            // Reverse一个只有一个元素的“元组”，但是有名字 Reverse
            // let right_min = self.right_hp.peek().unwrap().0 as f64;
            let Reverse(right_min) = *self.right_hp.peek().unwrap();
            return (left_max + right_min as f64) / 2.0
        }
        *self.left_hp.peek().unwrap() as f64
    }
}
```

运行结果
```
执行用时分布
37ms 击败87.50%

消耗内存分布
23.31MB 击败7.50%
```

欢迎来github上看更多题目的解答[力扣解题思路](https://github.com/WRAllen/LeetCode)
