# 题目[739. 每日温度](https://leetcode.cn/problems/daily-temperatures/description/?envType=study-plan-v2&envId=top-100-liked)

给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。

 

示例 1:

    输入: temperatures = [73,74,75,71,69,72,76,73]
    输出: [1,1,4,2,1,1,0,0]

示例 2:

    输入: temperatures = [30,40,50,60]
    输出: [1,1,1,0]

示例 3:

    输入: temperatures = [30,60,90]
    输出: [1,1,0]
 

提示：

    1 <= temperatures.length <= 105
    30 <= temperatures[i] <= 100
 


*****

# 解题思路

题目的意思也就是返回一个数组/列表，这个数组里面的值是后面比他大的值和当前下标的长度，

这里暴力的思路就很简单，首先第一个for循环，从头到尾，然后第二个for循环从第一个i位置+1进行，如果遍历到比下标i大的数

就把下标相减，放入结果。但是这样时间复杂度是o(n^2)肯定会超时的。

## 解法1 单调栈:

本质上是计算下标的差值，那如果我们把下标压入栈中，保证栈是递减的,这样如果新的数比栈里面最后一位还小，直接追加到栈尾。

如果新的数比栈尾的大，那就要开始pop栈，用栈尾依次和新的数比较，只到栈为空，或者栈里面有一个下标对应值比新的数大的也结束

那期间哪些比新的数小的，通过i2-i1就知道这个位置的最终值了，具体看代码。

### golang代码

```go
func dailyTemperatures(temperatures []int) []int {
    stack := make([]int, 0)
    // 先全部填充0
    result := make([]int, len(temperatures))
    for i := range temperatures{
        each := temperatures[i]
        // 栈为空（初始化）和栈末尾都大于当前值，直接追加到栈尾
        if len(stack) == 0 || temperatures[stack[len(stack)-1]] > each{
            stack = append(stack, i)
        } else {
            // 如果不是说明需要开始pop栈的操作了
            for {
                // 如果栈空了，那直接把当前的下标加入栈中，并且结束操作，等待下一次循环
                if len(stack) == 0 {
                    stack = append(stack, i)
                    break
                }
                // 栈pop操作
                last := stack[len(stack)-1]
                stack = stack[:len(stack)-1]
                // 如果栈尾的值要小于当前的值
                if temperatures[last] < each{
                    // 那说明找到栈尾出现比他高温度的时候了
                    result[last] = i - last
                } else {
                    // 如果栈尾比当前还高，那就把pop的栈尾恢复，并且把当前的加入栈中
                    stack = append(stack, last)
                    stack = append(stack, i)
                    break
                }
            }
        }
    }
    return result
}
```

运行结果
```
执行用时分布
4ms 击败81.55%

消耗内存分布
10.00MB 击败76.95%
```

上面的代码光`stack = append(stack, i)`就重复了三次了，明显不是那么优雅

可以把上诉的逻辑整理一下，反着写上面len(stack) == 0这块的else部分

```go
func dailyTemperatures(temperatures []int) []int {
    stack := make([]int, 0)
    result := make([]int, len(temperatures))
    for i := range temperatures{
        // 说明栈有值，并且栈尾的值还小于当前的值
        for len(stack) > 0 && temperatures[stack[len(stack)-1]] < temperatures[i] {
            // 栈pop操作
            last := stack[len(stack)-1]
            stack = stack[:len(stack)-1]
            // 设置当前数据的值
            result[last] = i - last
            // 这里如果栈尾还是小于，就一直循环
        }
        stack = append(stack, i)
    }
    return result
}
```

运行结果
```
执行用时分布
0ms 击败100.00%

消耗内存分布
11.04MB 击败7.85%
```

改完发现和官方的答案简直一毛一样:D

### python代码

翻译为python

```python
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        result = [0] * len(temperatures)
        stack = []
        for i in range(len(temperatures)):
            while stack and temperatures[stack[-1]] < temperatures[i]:
                last_index = stack.pop()
                result[last_index] = i - last_index
            stack.append(i)
        return result
```

运行结果
```
执行用时分布
95ms 击败69.63%

消耗内存分布
25.54MB 击败96.16%
```

### rust代码

又来了！rust！！

```rust
impl Solution {
    pub fn daily_temperatures(temperatures: Vec<i32>) -> Vec<i32> {
        let mut result: Vec<i32> = vec![0; temperatures.len()];
        let mut stack  = Vec::new();
        for (i, v) in temperatures.iter().enumerate(){
            while  stack.len() > 0 && temperatures[stack[stack.len()-1]] < *v {
                let last_index = stack.pop().unwrap();
                result[last_index] = (i - last_index) as i32;
            }
            stack.push(i);
        }
        result
    }
}
```

运行结果
```
执行用时分布
12ms 击败20.17%

消耗内存分布
4.40MB 击败41.18%
```

while这边的代码gpt给了个更rust的写法,以我现在的渣渣水平，还是上面我写的那种更容易让我理解
```rust
while let Some(&last) = stack.last() {
    if temperatures[last] < *v {
        stack.pop();
        result[last] = (i - last) as i32;
    } else {
        break;
    }
}
```

欢迎来github上看更多题目的解答[力扣解题思路](https://github.com/WRAllen/LeetCode)
