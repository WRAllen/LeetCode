# 题目[55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个位置。

示例 1:

```
输入: [2,3,1,1,4]
输出: true
解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
```

**示例 2:**

```
输入: [3,2,1,0,4]
输出: false
解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。
```



*****

# Python解题思路

现在做了几十题的LeetCode了，看到这种尝试类的题目，回溯肯定是能解决问题的(后面就打脸了)

先复习一个回溯解题的模板

```
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 新的选择列表)
        撤销选择
```

## 方法1：回溯算法---超时版

下面是根据回溯模板写出来的回溯代码

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        return self.jump(nums)

    def jump(self, nums):
        if len(nums) == 1: return True
        if nums[0] == 0: return False
        # 尝试进行跳跃
        for i in range(1, nums[0]+1):
            result = self.jump(nums[i:])
            # 如果找到结果就不进行无用的尝试了
            if result == True: break
        return result
```

本以为这样就可以通过测试了，可是...

运行结果

```
72 / 75 个通过测试用例        状态：超出时间限制
73号测试用例
[2,0,6,9,8,4,5,0,8,9,1,2,9,6,8,8,0,6,3,1,2,2,1,2,6,5,3,1,2,2,6,4,2,4,3,0,0,0,3,8,2,4,0,1,2,0,1,4,6,5,8,0,7,9,3,4,6,6,5,8,9,3,4,3,7,0,4,9,0,9,8,4,3,0,7,7,1,9,1,9,4,9,0,1,9,5,7,7,1,5,8,2,8,2,6,8,2,2,7,5,1,7,9,6]
```

卡在了73号测试用例。我看了一下测试用例，发现也不长一共也才104个。我放到本地测试了一下，发现也是一直在跑。卧槽是不是进入死循环了。深表怀疑但是我也无法去验证，因为太长了！！！

我想着会不会是比较特殊的用例，那我不从1开始尝试，我直接从当前最大能跳的情况开始尝试没准可以通过，

于是有了下面的代码

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        return self.jump(nums)

    def jump(self, nums):
        # 防止跳过了
        if not nums: return True
        if len(nums) == 1: return True
        if nums[0] == 0: return False
        for i in range(nums[0], 0, -1):
            result = self.jump(nums[i :])
            if result == True: break
        return result
```

运行结果

```
72 / 75 个通过测试用例        状态：超出时间限制
```

这打脸打的可真快真疼啊！o(╥﹏╥)o

好的既然如此！我只能....肿着脸换一种思路了(╯﹏╰)b

我突然又有另一种想法，反着来，因为正着来能成功的例子太多了，但是能导致识别的只有一种可能，那就是与0相关

思路变成在列表里面是否能找到0使得列表从右到左进行不下去（这就和小时候走迷宫一样，直接从终点往起点走往往会容易许多）

## 方法2：从后往前寻找0做判断

大体思路：从列表的后面往前寻找，遇到0就判断这个0的前面是否有个位置可以跳到这个0之后（不能只跳到0，因为跳到0后就死了）但是有个特例，在我测试的时候发现，用例[2, 0, 0]，如果按照前面的描述，这样就是false。但是其实是可以的，因为只会跳到0，但是这个0其实就是末尾，所以下面的代码如果遇到列表最后一位是0的话，用1替代（用什么去替代其实都可以，因为最后一位不影响）这样就统一了算法。

代码如下

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        if 0 not in nums: return True
        # 这里把最后一位是0的用1代替
        if nums[-1] == 0: nums[-1] = 1
        now_index = len(nums) - 1
        # 从后往前
        while now_index >= 0:
            if nums[now_index] != 0: now_index -= 1
            else:
                # 或者当前0下标的前一个下标tem_index
                tem_index = now_index - 1
                # 把这个下标tem_index往前推，找到能跳到0后面的位置
                while tem_index >= 0:
                    # 可以跳到0的下一位
                    if nums[tem_index] > now_index - tem_index:
                        now_index = tem_index
                        break
                    # 跳不到就继续往前
                    else: tem_index -= 1
                # 如果向前遍历结束还没有就返回False
                if tem_index == -1: return False
                # 找到了，继续循环找前面一个0
                else: now_index -= 1
        return True
```

运行结果

```
执行用时 :36 ms, 在所有 Python3 提交中击败了100.00% 的用户
内存消耗 :14.6 MB, 在所有 Python3 提交中击败了38.04%的用户

执行用时 :28 ms, 在所有 Python3 提交中击败了100.00% 的用户
内存消耗 :14.6 MB, 在所有 Python3 提交中击败了35.03%的用户

执行用时 :40 ms, 在所有 Python3 提交中击败了100.00% 的用户
内存消耗 :14.6 MB, 在所有 Python3 提交中击败了35.03%的用户
```

哇哦！这个用时看着是真的舒服！

官方肯定不是用这种方法做的，比较不够逼格。所以打算看一下官方的提示（相关标签）来寻求灵感(^▽^)

看到了贪心算法，(ˇˍˇ) 想～ 这要怎么贪呢？？？

看到贪心马上就想到，是不是用最大的去跳？感觉不像。最后打算直接参考嘿嘿

## 方法3：贪心算法

鉴于官方给的方法1，方法2，方法3都不是我想要的（我好奇怎么实现这个贪心），于是直接看方法4：贪心算法

看了官方的解释，然后再看了一下其他大神的代码，好似理解了,

**核心思想就是：遍历元素的时候，判断这个元素的位置是否是之前可以抵达的最远距离(MAX)，如果是则判断这个元素最大可以跳到哪里（贪心），取二者的最大值更新MAX**

最大可达到下标 用 MAX（初始化为列表第一位） 来代替

1.下面用可到达的测试用例来解释一下

```
值： 3  0  3  1  0  1
标： 0  1  2  3  4  5
当： |
初始化，MAX=3， 说明接下来的下标到3都是有效的（1, 2, 3）

值： 3  0  3  1  0  1
标： 0  1  2  3  4  5
当：    |
遇到0，MAX不变， 有效下标还是1，2，3

值： 3  0  3  1  0  1
标： 0  1  2  3  4  5
当：       |
遇到10， MAX 从3 变成5 （2 + 3）, 说明接下来的下标到5都是有效的（3， 4， 5）
```

2.下面用不可到达的测试用例来解释一下

```
值： 3  2  1  0  4
标： 0  1  2  3  4
当： |
初始化，MAX=3， 说明接下来的下标到3都是有效的（1, 2, 3）

值： 3  2  1  0  4
标： 0  1  2  3  4
当：    |
遇到2， MAX 不变，因为当前位置的最大值 1 + 2 = 3 不会大于MAX, 所以MAX还是3。说明接下来的下标到3都是有效的

值： 3  2  1  0  4
标： 0  1  2  3  4
当：       |
遇到1， MAX 不变，因为当前位置的最大值 2 + 1 = 3 不会大于MAX, 所以MAX还是3。说明接下来的下标到3都是有效的

值： 3  2  1  0  4
标： 0  1  2  3  4
当：          |
遇到4，由于4大于MAX,所以结束。
```

下面献上上面思路的代码

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        MAX = nums[0]
        for i in range(1, len(nums)):
            if i <= MAX: MAX = max(i+nums[i], MAX)
            else: return False
        return True
```

运行结果

```
执行用时 :100 ms, 在所有 Python3 提交中击败了88.13% 的用户
内存消耗 :15.3 MB, 在所有 Python3 提交中击败了6.03%的用户

执行用时 :96 ms, 在所有 Python3 提交中击败了93.94% 的用户
内存消耗 :15.5 MB, 在所有 Python3 提交中击败了5.09%的用户

执行用时 :108 ms, 在所有 Python3 提交中击败了70.20% 的用户
内存消耗 :15.5 MB, 在所有 Python3 提交中击败了5.09%的用户
```

哦豁，感觉还没有我方法2里面的快诶！不过代码着实减少了不少！

欢迎来github上看更多题目的解答[力扣解题思路](https://github.com/WRAllen/LeetCode)

  