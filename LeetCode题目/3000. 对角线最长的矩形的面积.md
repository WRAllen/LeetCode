# 题目[3000. 对角线最长的矩形的面积](https://leetcode.cn/problems/maximum-area-of-longest-diagonal-rectangle/description/)

给你一个下标从 0 开始的二维整数数组 dimensions。

对于所有下标 i（0 <= i < dimensions.length），dimensions[i][0] 表示矩形 i 的长度，而 dimensions[i][1] 表示矩形 i 的宽度。

返回对角线最 长 的矩形的 面积 。如果存在多个对角线长度相同的矩形，返回面积最 大 的矩形的面积。

 

示例 1：

```
输入：dimensions = [[9,3],[8,6]]
输出：48
解释：
下标 = 0，长度 = 9，宽度 = 3。对角线长度 = sqrt(9 * 9 + 3 * 3) = sqrt(90) ≈ 9.487。
下标 = 1，长度 = 8，宽度 = 6。对角线长度 = sqrt(8 * 8 + 6 * 6) = sqrt(100) = 10。
因此，下标为 1 的矩形对角线更长，所以返回面积 = 8 * 6 = 48。
```
示例 2：
```
输入：dimensions = [[3,4],[4,3]]
输出：12
解释：两个矩形的对角线长度相同，为 5，所以最大面积 = 12。
```



*****

# Go解题思路

## 方法1:根据逻辑code

该题比较简单，属于把自然语言变成程序代码，核心为记录最大的对角线，并且要是长宽乘机也是最大的，那自然就会想到，记录一下最大的对角线，和其长宽。

```go
func areaOfMaxDiagonal(dimensions [][]int) int {
	maxSqrtNum := 0.0
	maxIndex := 0
	for i := range dimensions {
		length := dimensions[i][0]
		wight := dimensions[i][1]
		tmpSqrtNum := math.Sqrt(float64(length*length + wight*wight))
		// 如果当前的对角线比之前的最大对角线要大，那就无脑更新
		if tmpSqrtNum > maxSqrtNum {
			maxSqrtNum = tmpSqrtNum
			maxIndex = i
		} else if tmpSqrtNum == maxSqrtNum {
			// 如果对角线相等，那就比较面积
			if length*wight > dimensions[maxIndex][0] * dimensions[maxIndex][1] {
				maxIndex = i
			}
		}

	}
	return dimensions[maxIndex][0]*dimensions[maxIndex][1]
}
```
# Python解题思路

## 方法1:同go
把go代码翻译成了pyhon的代码

```python
class Solution(object):
    def areaOfMaxDiagonal(self, dimensions):
        """
        :type dimensions: List[List[int]]
        :rtype: int
        """
        max_sqrt_num = 0
        max_index = 0
        for i, value in enumerate(dimensions):
            length = value[0]
            wight = value[1]
            tmp_sqrt_num = math.sqrt(float(length*length + wight*wight))
            if tmp_sqrt_num > max_sqrt_num:
                max_sqrt_num = tmp_sqrt_num
                max_index = i
            elif tmp_sqrt_num == max_sqrt_num:
                if length*wight > dimensions[max_index][0] * dimensions[max_index][1]:
                    max_index = i
        return dimensions[max_index][0] * dimensions[max_index][1]
```








欢迎来github上看更多题目的解答[力扣解题思路](https://github.com/WRAllen/LeetCode)



