# 题目[394. 字符串解码](https://leetcode.cn/problems/decode-string/description/?envType=study-plan-v2&envId=top-100-liked)

给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。

测试用例保证输出的长度不会超过 105。

 

示例 1：

    输入：s = "3[a]2[bc]"
    输出："aaabcbc"

示例 2：

    输入：s = "3[a2[c]]"
    输出："accaccacc"

示例 3：

    输入：s = "2[abc]3[cd]ef"
    输出："abcabccdcdcdef"

示例 4：

    输入：s = "abc3[cd]xyz"
    输出："abccdcdcdxyz"
 

提示：

    1 <= s.length <= 30
    s 由小写英文字母、数字和方括号 '[]' 组成
    s 保证是一个 有效 的输入。
    s 中所有整数的取值范围为 [1, 300] 

*****

# 解题思路

题目说的也比较清楚了，就是把 数字[子表达式] 变成 [子表达式]*数字出现的次数，并且子表达式里面可能也可能有这种嵌套的情况

PS：诶，今天是2025年12月31日呢，25年最后一天了

## 解法1 栈:

话说点进这题的时候不小心看到了他的分类（因为我是从热题100进来的）当然多思考一下也知道要用栈的方式来解决问题

因为 "[" 和 "]" 肯定是成对出现的，那可以先简单想象一下，把`[`押入栈，然后遇到`]`的时候一直进行pop操作

遇到了`[`就停止，然后获取一下`[`前面的数字，*这个数字的次数构造新的数据，然后再次压入栈（因为存在`[xxx[xxx`这种套娃行为）

所以是需要把处理后的数据再次压入，直到又遇到下一个`[`

但是处理字符串的数值这个还是挺麻烦的，因为他是1～300，要是他是个位数的话，就比较简单了

### golang代码

先把数字的字符串先当做是1～10，这样便于我们先写入整体思路，然后再来思考怎么解决多个字符数组的问题

```go
func decodeString(s string) string {
    // 用来存储数值字符串的栈，下面简称：数字栈
    numList := make([]int, 0)
    // 字符串的栈 下面简称：字符栈
    charList := make([]string, 0)
    for i := range s{
        each := string(s[i])
        switch {
            // 如果这个字符串是数字，就压入数字栈
            case each >= "0" && each <= "9": {
                num, _ := strconv.Atoi(each)
                numList = append(numList, num)
            }
            // 先写default的逻辑，再来写这里
            case each == "]": {
                // 搞个临时列表，用来处理从字符栈里面pop出来的字符
                tmpList := make([]string, 0)
                for {
                    // 获取字符栈最后一个字符
                    lastChar := charList[len(charList)-1]
                    // 字符栈pop操作
                    charList = charList[:len(charList)-1]
                    /// 这里可以适当print一下看一下输出
                    // fmt.Println("lastChar:", lastChar, "tmpList:", tmpList)
                    // 如果pop出来的是[,说明要开始处理tmpList了，需要把tmpList处理后的数据再次压入字符栈
                    if lastChar == "[" {
                        // 默认tmpList要重复的次数 x次
                        totalNum := 1
                        if len(numList) > 0 {
                            // 从之前的数字栈里面获取最后一个
                            totalNum = numList[len(numList)-1]
                            // 数字栈pop操作
                            numList = numList[:len(numList)-1]
                            // 这里[和数字一定是成双成对的出现的
                        }
                        // 循环x次
                        for _ = range totalNum{
                            // 因为是倒叙的，所以这里倒叙遍历，这样负负得正
                            for z := len(tmpList) - 1; z >= 0; z -- {
                                // 把字符串在压入字符栈，为下一次处理[做准备
                                charList = append(charList, tmpList[z])
                            }
                        }
                        break
                    // 如果不是[，说明就是普通字符，记录在tmpList里，为后续处理tmpList
                    } else {
                        tmpList = append(tmpList, lastChar)
                    }
                }
            }
            // 除了]和数字外，其他的就是无脑append到字符栈里
            default: {
                charList = append(charList, each)
            }
        }
    }
    result := ""
    for i := range charList{
        result += charList[i]
    }
    return result
}

```

上面的代码我们没有处理，数字大于10的case，但是不管，我就运行

运行结果
```
解答错误
23 / 34 个通过的测试用例

官方题解
输入
s =
"100[leetcode]"
```

可以看到，果然是大于10的case没通过，但是还是通过了23个，说明写的逻辑整体上是正确的

下面我们就来把这个数字的问题解决一下（PS：这里可以点击页面上的“添加到测试用例”，方便下次测试）

那怎么处理数字呢，也可以用一个字符串，来记录，如果遇到数字字符，就先+到这个字符串尾巴，遇到`[`或字母了，去处理一下就好了

代码如下
```go
func decodeString(s string) string {
    // 用来存储数值字符串的栈，下面简称：数字栈
    numList := make([]int, 0)
    // 字符串的栈 下面简称：字符栈
    charList := make([]string, 0)
    // 准备数字字符串处理大于10的问题 下面简称：数字串
    numStr := ""
    for i := range s{
        each := string(s[i])
        switch {
            // 如果这个字符串是数字，就先记录到数字串里面
            case each >= "0" && each <= "9": {
                numStr += each
            }
            // 先写default的逻辑，再来写这里
            case each == "]": {
                // 搞个临时列表，用来处理从字符栈里面pop出来的字符
                tmpList := make([]string, 0)
                for {
                    // 获取字符栈最后一个字符
                    lastChar := charList[len(charList)-1]
                    // 字符栈pop操作
                    charList = charList[:len(charList)-1]
                    /// 这里可以适当print一下看一下输出
                    // fmt.Println("lastChar:", lastChar, "tmpList:", tmpList)
                    // 如果pop出来的是[,说明要开始处理tmpList了，需要把tmpList处理后的数据再次压入字符栈
                    if lastChar == "[" {
                        // 默认tmpList要重复的次数 x次
                        totalNum := 1
                        if len(numList) > 0 {
                            // 从之前的数字栈里面获取最后一个
                            totalNum = numList[len(numList)-1]
                            // 数字栈pop操作
                            numList = numList[:len(numList)-1]
                            // 这里[和数字一定是成双成对的出现的
                        }
                        // 循环x次
                        for _ = range totalNum{
                            // 因为是倒叙的，所以这里倒叙遍历，这样负负得正
                            for z := len(tmpList) - 1; z >= 0; z -- {
                                // 把字符串在压入字符栈，为下一次处理[做准备
                                charList = append(charList, tmpList[z])
                            }
                        }
                        break
                    // 如果不是[，说明就是普通字符，记录在tmpList里，为后续处理tmpList
                    } else {
                        tmpList = append(tmpList, lastChar)
                    }
                }
            }
            // 除了]和数字外，其他的就是无脑append到字符栈里
            default: {
                charList = append(charList, each)
                // 如果数字串不为空说明之前有记录过数字
                if numStr != ""{
                    // str 转 int
                    num, _ := strconv.Atoi(numStr)
                    // 加入数字栈
                    numList = append(numList, num)
                    // 记得清空，为下次做准备
                    numStr = ""
                }
            }
        }
    }
    result := ""
    for i := range charList{
        result += charList[i]
    }
    return result
}

```

运行结果
```
执行用时分布
0ms 击败100.00%

消耗内存分布
7.89MB 击败5.20%
```



### python代码

照旧翻译为python，诶呀，go写多了，老是加上{},还有就是for老是写成go的形式:(

```python
class Solution:
    def decodeString(self, s: str) -> str:
        char_list = []
        num_list = []
        num_str = ""
        for each in s:
            match each:
                case c if "0" <= c <= "9":
                    num_str += c
                case "]":
                    tmp_list = []
                    while True:
                        last_char = char_list.pop()
                        if last_char == "[":
                            total_num = 1
                            if num_list:
                                total_num = num_list.pop()
                            for _ in range(total_num):
                                for y in range(len(tmp_list)-1, -1, -1):
                                    char_list.append(tmp_list[y])
                            break
                        else:
                            tmp_list.append(last_char)
                case _:
                    char_list.append(each)
                    if num_str:
                        num_list.append(int(num_str))
                        num_str = ""

        return "".join(char_list)

```

u1s1，这函数里面也斜的太猛了，一点都不pythonic(对于for都忘记怎么写的人，有点搞笑了:D)

运行结果
```
执行用时分布
0ms 击败100.00%

消耗内存分布
17.01MB 击败95.38%
```


### rust代码

接下来就是重头戏了，改写为rust........

学了rust5天了，感觉自己啥也不会写，除了let x = xxx;比较熟练外，其他真的不会，rust怎么这么难入门啊（2025.12.31）

```rust
impl Solution {
    pub fn decode_string(s: String) -> String {
        let mut num_list: Vec<i32> = Vec::new();
        let mut char_list: Vec<char> = Vec::new();
        let mut num_str = String::new();
        
        for b in s.bytes(){
            let each = b as char;
            match each {
                '0'..='9' => {
                    num_str.push(each);
                },
                ']' => {
                    let mut tmp_list = Vec::new();
                    loop {
                        let last_char = char_list.pop().unwrap();
                        if last_char == '['{
                            let total_num = if !num_list.is_empty() {
                                num_list.pop().unwrap()
                            } else {
                                1
                            };
                            for _ in 0..total_num{
                                for i in (0..tmp_list.len()).rev(){
                                    char_list.push(tmp_list[i]);
                                }
                            }
                            break;
                        }else {
                            tmp_list.push(last_char);
                        }
                    }
                },
                _ => {
                    char_list.push(each);
                    if !num_str.is_empty(){
                        let num = num_str.parse().unwrap();
                        num_list.push(num);
                        num_str.clear();
                    }
                },
            }
        }
    char_list.iter().collect()
    }
}

```

运行结果
```
执行用时分布
0ms 击败100.00%

消耗内存分布
2.15MB 击败67.35%
```

欢迎来github上看更多题目的解答[力扣解题思路](https://github.com/WRAllen/LeetCode)
