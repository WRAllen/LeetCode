# é¢˜ç›®[102. äºŒå‰æ ‘çš„å±‚æ¬¡éå†](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¿”å›å…¶æŒ‰å±‚æ¬¡éå†çš„èŠ‚ç‚¹å€¼ã€‚ ï¼ˆå³é€å±‚åœ°ï¼Œä»å·¦åˆ°å³è®¿é—®æ‰€æœ‰èŠ‚ç‚¹ï¼‰ã€‚

ä¾‹å¦‚:
```
ç»™å®šäºŒå‰æ ‘: [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7
```

è¿”å›å…¶å±‚æ¬¡éå†ç»“æœï¼š

```
[
  [3],
  [9,20],
  [15,7]
]
```

*****

# Pythonè§£é¢˜æ€è·¯

è¿™é¢˜æœ‰æ„æ€äº†ï¼Œä¸€çœ‹åˆ°æ ‘å•¥çš„æƒ³åˆ°çš„è§£é¢˜æ–¹å¼éƒ½æ˜¯æ·±åº¦ä¼˜å…ˆ(DFS)ï¼Œè¿™é¢˜è¦æˆ‘ä»¬å®½åº¦ä¼˜å…ˆ(BFS)ã€‚

## æ–¹æ³•1ï¼šè¿­ä»£ç®—æ³•-(BFS)

å€ŸåŠ©ä¸€ä¸‹ä¹‹å‰çš„ä¸­åºéå†ï¼Œæ„Ÿè§‰å¯ä»¥è¯•è¯•ç”¨æ ˆæ¥å­˜å‚¨rootï¼Œæ¯æ¬¡éå†éƒ½æŠŠstackç»™popç©ºï¼Œ åœ¨popçš„æ—¶å€™ç›¸å…³çš„valï¼Œä¹‹åå†æŠŠrightï¼Œleftä¾æ¬¡appendåˆ°å¦ä¸€ä¸ªæ ˆé‡Œé¢ã€‚å½“stackéƒ½popç©ºä¹‹åï¼ŒæŠŠå¦ä¸€ä¸ªæ ˆç›´æ¥èµ‹äºˆstackã€‚

å®‰è£…è¿™ç§æ€è·¯å†™äº†ä¸‹é¢çš„ä»£ç ï¼ˆé”™è¯¯ï¼‰

```python
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:        
        result = []
        if not root: return result
        stack = [root]
        while stack:
            tem_result = []
            next_stack = []
            # ä¸€ç›´æŠŠstack popåˆ°ç©º
            while stack:
                current = stack.pop()
                tem_result.append(current.val)
                if current.right: next_stack.append(current.right)
                if current.left: next_stack.append(current.left)
            result.append(tem_result)
            stack = next_stack
        return result
```

è¿è¡Œç»“æœ

```
15 / 34 ä¸ªé€šè¿‡æµ‹è¯•ç”¨ä¾‹
	çŠ¶æ€ï¼šè§£ç­”é”™è¯¯
	
æäº¤æ—¶é—´ï¼š0 åˆ†é’Ÿä¹‹å‰
è¾“å…¥ï¼š [1,2,3,4,null,null,5]
è¾“å‡ºï¼š [[1],[2,3],[5,4]]
é¢„æœŸï¼š [[1],[2,3],[4,5]]
```

å—¯å“¼ï¼Ÿæ€ä¹ˆä¸è¡Œå‘¢ï¼Ÿä¸ºå•¥4å’Œ5çš„ä½ç½®é”™äº†ï¼Ÿï¼Ÿï¼Ÿè¿™ä¸ªäºŒå‰æ ‘é•¿è¿™ä¸ªæ ·å­

```
     1
    / \
   2   3
  /     \
 4       5
```

æˆ‘ä»¬æ¥ä¿®æ”¹æ¼”ç®—ä¸€ä¸‹

```
     1
    / \
   2   3
  /   / \
 4    5  6
 å¯¹äºstack = [1] æ—¶, å¯¹äºæ¯ä¸€ä¸ªå­èŠ‚ç‚¹ï¼Œè¦å…ˆå³åå·¦
 	tem_stack = [3, 2]
 è¿™æ—¶æŠŠåŸå…ˆçš„stackå€’å™å¾ªç¯(pop)èµ‹äºˆæœ€ç»ˆresult = [[1]]
 
 å¯¹äºstack = [3, 2], å¯¹äºstackåˆ™è¦æ˜¯å…ˆå·¦å†å³
 	å…ˆæŠŠ3æå‡ºæ¥ï¼Œå¯¹äºæ¯ä¸€ä¸ªå­èŠ‚ç‚¹ï¼Œè¦å…ˆå³åå·¦
 		tem_stack = [6, 5]
 	å†æŠŠ2æå‡ºæ¥ï¼Œå¯¹äºæ¯ä¸€ä¸ªå­èŠ‚ç‚¹ï¼Œè¦å…ˆå³åå·¦
 		tem_stack = [6, 5, 4]
 è¿™æ—¶æŠŠåŸå…ˆçš„stackå€’å™å¾ªç¯(pop)èµ‹äºˆæœ€ç»ˆresult = [[1], [2ï¼Œ 3]], å¹¶ä¸”æŠŠtem_stackèµ‹äºˆstack
 
 å¯¹äºstack = [6 , 5, 4]
 	tem_stack ç»è¿‡ä¸Šé¢éå†è¿˜æ˜¯[]
 è¿™æ—¶æŠŠåŸå…ˆçš„stackå€’å™å¾ªç¯(pop)èµ‹äºˆæœ€ç»ˆresult = [[1], [2ï¼Œ 3], [4, 5, 6]], å¹¶ä¸”æŠŠtem_stackèµ‹äºˆstack
 
 ç”±äºstackä¸º[]ç»“æŸå¾ªç¯
```

æŒ‰ç…§è¿™ç§æ€è·¯æœ‰äº†ä¸‹é¢çš„ä»£ç 

```python
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:        
        result = []
        if not root: return result
        stack = [root]
        while stack:
            next_stack = []
            for current in stack:
                if current.right: next_stack.append(current.right)
                if current.left: next_stack.append(current.left)
            # ä¸‹é¢å¼€å§‹popæ•°æ®åˆ°resut
            tem_result = []
            while stack:
                current = stack.pop()
                tem_result.append(current.val)
            result.append(tem_result)
            stack = next_stack
        return result
```

è¿è¡Œç»“æœ

```
æ‰§è¡Œç”¨æ—¶ :40 ms, åœ¨æ‰€æœ‰ Python3 æäº¤ä¸­å‡»è´¥äº†57.84% çš„ç”¨æˆ·
å†…å­˜æ¶ˆè€— :13.6 MB, åœ¨æ‰€æœ‰ Python3 æäº¤ä¸­å‡»è´¥äº†16.05%çš„ç”¨æˆ·

æ‰§è¡Œç”¨æ—¶ :44 ms, åœ¨æ‰€æœ‰ Python3 æäº¤ä¸­å‡»è´¥äº†36.46% çš„ç”¨æˆ·
å†…å­˜æ¶ˆè€— :13.8 MB, åœ¨æ‰€æœ‰ Python3 æäº¤ä¸­å‡»è´¥äº†15.20%çš„ç”¨æˆ·

æ‰§è¡Œç”¨æ—¶ :44 ms, åœ¨æ‰€æœ‰ Python3 æäº¤ä¸­å‡»è´¥äº†36.46% çš„ç”¨æˆ·
å†…å­˜æ¶ˆè€— :13.5 MB, åœ¨æ‰€æœ‰ Python3 æäº¤ä¸­å‡»è´¥äº†16.30%çš„ç”¨æˆ·
```

æˆ‘ç°åœ¨ç®—è¿›ä¸€æ­¥åŠ æ·±é€’å½’å’Œè¿­ä»£çš„åŒºåˆ«äº†ï¼Œä¸Šé¢è¿™ç§å°±æ˜¯å±äºè¿­ä»£ï¼Œå› ä¸ºAé‡Œé¢ä¸æ–­çš„è°ƒç”¨B(æ³›æŒ‡ä¸€äº›æ“ä½œ)

ä¸‹é¢çœ‹ä¸€ä¸‹å®˜æ–¹çš„è§£é¢˜æ€è·¯

## æ–¹æ³•2ï¼šé€’å½’-(DFS)

çœ‹åˆ°å®˜æ–¹é€’å½’çš„è§£é¢˜æ€è·¯åï¼Œæˆ‘å‘ç°æˆ‘ä¹‹å‰ä¹Ÿæœ‰ç±»ä¼¼çš„æƒ³æ³•ï¼Œç”¨ä¸€ä¸ªå˜é‡æ¥è®°å½•æ˜¯ç¬¬å‡ å±‚çš„æƒ…å†µï¼Œä½†æ˜¯æˆ‘é™¤äº†è¿™ä¸ªæ€è·¯å¯¹äº†ä¹‹å¤–å‰©ä¸‹çš„éƒ½åäº†ï¼ˆåé¢æˆ‘å°±æƒ³ï¼Œé‚£æ·±åº¦ä¼˜å…ˆéå†çš„æ—¶å€™æˆ‘è¦æ€ä¹ˆè®°å½•ä¹‹é—´çš„å…³ç³»å•¥çš„ï¼Œè¶Šæƒ³è¶Šä¹±ï¼Œäºæ˜¯æ”¾å¼ƒï¼‰ã€‚

çœ‹äº†ä¸€ä¸‹æ€è·¯ï¼Œæœ‰ä¸€ç‚¹ä¸ªäººè§‰å¾—ååˆ†é‡è¦ï¼Œé‚£å°±æ˜¯`if len(result) == level: result.append([])`

ä¹‹å‰æˆ‘åˆ°è¿™é‡Œå°±æœ‰ä¸¤ç‚¹ç–‘æƒ‘ï¼š

> 1.ä¸ºå•¥æ˜¯ç»“æœçš„é•¿åº¦ç­‰äºæ–°çš„å±‚çº§çš„æ—¶å€™å»åˆ›å»ºè¿™ä¸€å±‚çš„ç»“æœ
>
> 2.å‡å¦‚æ˜¯åªæœ‰ä¸¤å±‚çš„å®Œå…¨äºŒå‰æ ‘ï¼Œé‚£é‡åˆ°å·¦èŠ‚ç‚¹ååˆ›å»ºæ–°çš„ä¸€å±‚ï¼Œé‚£å³è¾¹å‘¢ï¼Ÿ

é‚£å…ˆè¯´ç¬¬ä¸€ç‚¹ï¼Œæ‹¿å‡ ä¸ªä¾‹å­å°±çŸ¥é“äº†ï¼Œå½“ level=0çš„æ—¶å€™len(result)=0ï¼Œæ‰€ä»¥è¦åŠ ä¸€ä¸ª[],ã€‚å› ä¸ºå½“level=1çš„æ—¶å€™ï¼Œè¿™æ—¶len(result)è¿˜æ˜¯0ï¼Œå½“æ˜¯æ˜æ˜¾è¿™é‡Œéœ€è¦åˆ›å»ºæ–°çš„ä¸€å±‚ç”¨äºå­˜å‚¨æ•°æ®ã€‚æ‰€ä»¥å½“é‡åˆ°æ–°çš„levelçš„æ—¶å€™è¦åˆ›å»ºå¯¹åº”å¾—å±‚çº§

é‚£å†è¯´ç¬¬ä¸€ç‚¹ï¼Œè¿™ç‚¹æ›´ç®€å•ï¼Œleftåˆ›å»ºæ–°çš„ä¸€å±‚çš„æ—¶å€™ï¼Œlen(result)å°±å·²ç»æ˜¯å¤§äº>rightå½“å‰çš„leveläº†ï¼Œç®€å•æ¥è¯´å°±æ˜¯ï¼Œå› ä¸ºleftçš„æ—¶å€™appendäº†[]ï¼Œ æ‰€ä»¥rightçš„æ—¶å€™å°±ä¸ä¼šappendï¼ˆlen(result)>levelï¼‰

äºæ˜¯ç†è§£äº†å…³é”®çš„è¯­å¥å‰©ä¸‹çš„å°±ä¸æ˜¯é—®é¢˜äº†ã€‚

```python
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:        
        result = []
        if not root: return result
        return self.help(root, 0, result)

    def help(self, root, level, result):
        if not root: return result
        if len(result) == level: result.append([])
        result[level].append(root.val)
        if root.left: self.help(root.left, level + 1, result)
        if root.right: self.help(root.right, level + 1, result)
        return result
```

è¿è¡Œç»“æœ

```
æ‰§è¡Œç”¨æ—¶ :44 ms, åœ¨æ‰€æœ‰ Python3 æäº¤ä¸­å‡»è´¥äº†36.54% çš„ç”¨æˆ·
å†…å­˜æ¶ˆè€— :14.2 MB, åœ¨æ‰€æœ‰ Python3 æäº¤ä¸­å‡»è´¥äº†5.57%çš„ç”¨æˆ·

æ‰§è¡Œç”¨æ—¶ :44 ms, åœ¨æ‰€æœ‰ Python3 æäº¤ä¸­å‡»è´¥äº†36.54% çš„ç”¨æˆ·
å†…å­˜æ¶ˆè€— :14 MB, åœ¨æ‰€æœ‰ Python3 æäº¤ä¸­å‡»è´¥äº†9.54%çš„ç”¨æˆ·

æ‰§è¡Œç”¨æ—¶ :36 ms, åœ¨æ‰€æœ‰ Python3 æäº¤ä¸­å‡»è´¥äº†78.68% çš„ç”¨æˆ·
å†…å­˜æ¶ˆè€— :14 MB, åœ¨æ‰€æœ‰ Python3 æäº¤ä¸­å‡»è´¥äº†9.03%çš„ç”¨æˆ·
```

æ¬¢è¿æ¥githubä¸Šçœ‹æ›´å¤šé¢˜ç›®çš„è§£ç­”[åŠ›æ‰£è§£é¢˜æ€è·¯](https://github.com/WRAllen/LeetCode)

  

# goè§£é¢˜æ€è·¯

åš[543. äºŒå‰æ ‘çš„ç›´å¾„](https://leetcode.cn/problems/diameter-of-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked)è¿™é¢˜çš„æ—¶å€™ï¼Œåˆå›é¡¾åˆ°è¿™é¢˜äº†

è¯¶ï¼Œå†™102è¿™é¢˜çš„æ—¶å€™æˆ‘çœ‹äº†ä¸€ä¸‹æ—¶é—´ï¼Œæ˜¯2020.03.06ï¼Œå’Œä»Šå¤©2025.11.24ï¼Œæ•´æ•´å¤šäº†5å¹´æ—¶é—´ï¼Œtimes flieså•Šï¼Œ

é‚£æ—¶çš„leetcodeè¿˜ä¸é•¿ç°åœ¨è¿™æ ·ï¼ŒåŸŸåè¿˜æ˜¯leetcode-cn.comè€Œä¸æ˜¯ç°åœ¨çš„leetcode.cn

é‚£æ—¶æˆ‘æ˜¯ä¸ªpythonerï¼Œç°åœ¨æˆ‘æˆä¸ºä¸€ä¸ªgopheräº†

æ²¡æœ‰ä»»ä½•çš„æ„æ€ï¼Œåªæ˜¯æ„Ÿæ…¨è¿™5å¹´çš„å˜åŒ–ï¼ŒPSï¼šè¿™ä¸¤é—¨è¯­è¨€æˆ‘éƒ½éå¸¸å–œæ¬¢ğŸ˜

ç”¨dfsï¼ˆdeep first searchï¼‰çš„æ–¹å¼ï¼Œgoä»£ç å¦‚ä¸‹
```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

var info [][]int

func levelOrder(root *TreeNode) [][]int {
    info = make([][]int, 0)
    dfs(0, root)
    return info
}

func dfs(level int, root *TreeNode) {
    if root == nil {
        return 
    }
    // è¿™é‡Œè¿™ä¸ªåˆ¤æ–­ä¸€ä¸‹å­æ²¡æƒ³å¥½ï¼Œå†™æˆäº†len(info[level]) == 0
    // ä¸Šé¢è¿™æ ·æ˜¯ä¸å¯¹çš„ï¼Œä¼šè¶Šç•Œ
    // ä¸‹é¢è¿™æ ·æ˜¯åˆç†çš„ï¼Œåˆšå¼€å§‹levelæ˜¯0ï¼Œlen(info)ä¹Ÿæ˜¯0ï¼Œè¿™æ—¶å°±ä¼šè¿›è¡Œåˆå§‹åŒ–äº†
    // è€Œåˆ°ä¸‹ä¸€å±‚çš„æ—¶å€™ï¼Œinfoåˆå§‹åŒ–äº†level-1çš„æ•°æ®ï¼Œæ‰€ä»¥è¿™é‡Œæ­£å¥½ä¹Ÿä¼šç›¸ç­‰ï¼Œè¿›è¡Œåˆå§‹åŒ–level+1çš„æ•°æ®
    // æ„Ÿè§‰å¥½å·§å¦™
    if level == len(info) {
        info = append(info, []int{})
    }
    info[level] = append(info[level], root.Val)
    dfs(level+1, root.Left)
    dfs(level+1, root.Right)
}
```

è¿è¡Œç»“æœ
```
æ‰§è¡Œç”¨æ—¶åˆ†å¸ƒ
0ms å‡»è´¥100.00%

æ¶ˆè€—å†…å­˜åˆ†å¸ƒ
5.57MB å‡»è´¥5.17%
```
