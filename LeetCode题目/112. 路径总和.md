# 题目[112. 路径总和](https://leetcode.cn/problems/path-sum/description/)

给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。

叶子节点 是指没有子节点的节点。

 

示例 1：

![1](https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg)


    输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
    输出：true
    解释：等于目标和的根节点到叶节点路径如上图所示。

示例 2：

![2](https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg)

    输入：root = [1,2,3], targetSum = 5
    输出：false
    解释：树中存在两条根节点到叶子节点的路径：
    (1 --> 2): 和为 3
    (1 --> 3): 和为 4
    不存在 sum = 5 的根节点到叶子节点的路径。

示例 3：

    输入：root = [], targetSum = 0
    输出：false
    解释：由于树是空的，所以不存在根节点到叶子节点的路径。
 

提示：

    树中节点的数目在范围 [0, 5000] 内
    -1000 <= Node.val <= 1000
    -1000 <= targetSum <= 1000

*****

# 解题思路

就是从root节点一直向下，一直到叶子节点（也就是一定要到树的底部，不能到中间就结束了），是否有相加等于targetSum的路线

## 解法1 回溯:

注意一点，因为node的val可能是负数，所以没遍历到最后，也不知道他是否会成功，所以这是一个不断尝试的事情

那这也比较符合回溯的算法，每条路径都去尝试一遍，如果错误，就会退到探索前的情形，

就像是打游戏，打boss前先存个档，把当时的状态都保留下来

那怎么判断是否存在呢，那就是total==targetSum是否成立，也可以变成targetSum-total==0

所以，每个node的存档状态就是当前targetSum减去到这个node时所有相加的total

话不多说，直接上代码

### golang代码1-失败

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func hasPathSum(root *TreeNode, targetSum int) bool {
    if root == nil{
        return false
    }
    return backtracking(root, targetSum)
}

func backtracking(root *TreeNode, target int) bool {
    if root == nil && target == 0 {
        return true
    }
    if root == nil {
        return false
    }
    target -= root.Val
    // 为啥这里不用恢复target状态呢，因为本来在开启回溯前我的target就是要-=的
    if backtracking(root.Left, target){
        return true
    }
    // 上面走left之前是target，因为他失败了，下面走right的时候也是target，所以已经是回溯前的状态了
    if backtracking(root.Right, target){
        return true
    }
    return false
}

```

运行结果
```
解答错误
106 / 118 个通过的测试用例
```

坑爹了，遇到了个case如下

    root = [1,2]
    targetSum =1

这里题目要的是叶子节点，这里我之前的代码，这部分
```go
    if root == nil && target == 0 {
        return true
    }
```
直接就return true了，把root当成是叶子节点了, 所以递归里面的判断逻辑不能用root，而是需要使用左右节点

### golang代码2

所以递归里面的判断，用当前node的左右节点是否为nil，加上target-当前node的val是否为0作为依据

代码如下

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func hasPathSum(root *TreeNode, targetSum int) bool {
    return backtracking(root, targetSum)
}

func backtracking(root *TreeNode, target int) bool {
    if root == nil {
        return false
    }
    newTarget := target - root.Val 
    if root.Left == nil && root.Right == nil && newTarget == 0 {
        return true
    }
    if backtracking(root.Left, newTarget){
        return true
    }
    if backtracking(root.Right, newTarget){
        return true
    }
    return false
}
```

运行结果
```
执行用时分布
0ms 击败100.00%

消耗内存分布
6.38MB 击败100.00%
```

哇哦，双百！给自己点个赞（doge）


### python代码

直接翻译golang2为python

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def hasPathSum(self, root: Optional[TreeNode], targetSum: int) -> bool:
        return self.backtracking(root, targetSum)
    
    def backtracking(self, root, target):
        if root is None:
            return False
        new_target = target - root.val
        if root.left is None and root.right is None and new_target == 0:
            return True
        if self.backtracking(root.left, new_target):
            return True
        if self.backtracking(root.right, new_target):
            return True
        return False

```

运行结果
```
执行用时分布
0ms 击败100.00%

消耗内存分布
18.50MB 击败86.54%
```


欢迎来github上看更多题目的解答[力扣解题思路](https://github.com/WRAllen/LeetCode)
