# 题目[438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/?envType=study-plan-v2&envId=top-100-liked)

给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

 
示例 1:
```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```

示例 2:

```
输入: s = "abab", p = "ab"
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。
```
 

提示:

    1 <= s.length, p.length <= 3 * 104
    s 和 p 仅包含小写字母


*****

# 解题思路

看题目的意思，简单思考一下就是使用滑动窗口的方式，依次根据p的长度开始在s上面进行滑动判断，

然后如果符合要求（也就是两个字符串在字母和字母数量上面是相等的）就把当前的坐标记录一下

## 解法1-滑动窗口:

### golang代码1

根据上面的思路，那问题的关键点就在于如何判断两个字符串是符合要求的，这里用最原始的方式，通过两个map进行记录

```go
func findAnagrams(s string, p string) []int {
    result := make([]int, 0)
	if len(s) < len(p) || len(p) == 0{
		return result
	}
    pInfoMap := make(map[rune]int)
    for _, v := range p {
        _, ok := pInfoMap[v]
        if ok {
            pInfoMap[v] += 1
        } else {
            pInfoMap[v] = 1
        }
    }

    for i := range len(s) - len(p) + 1{
		endIndex := i + len(p)
        // 获取当前的字母串subStr
        subStr := s[i:endIndex]
        // 比较substr是否和p相等，问题变成比较两个字符串是否“相等”
        subStrInfoMap := make(map[rune]int)
        for _, v := range subStr {
            _, ok := subStrInfoMap[v]
            if ok {
                subStrInfoMap[v] += 1
            } else {
                subStrInfoMap[v] = 1
            }
        }
        // 把字符串的比较，转化为两个map的比较
        if len(pInfoMap) != len(subStrInfoMap) {
            continue
        }
        isSame := true
        for k, v := range pInfoMap {
            checkV, ok := subStrInfoMap[k]
            if !ok {
                isSame = false
                break
            }
            if checkV != v {
                isSame = false
                break
            }
        }
        for k, v := range subStrInfoMap {
            checkV, ok := pInfoMap[k]
            if !ok {
                isSame = false
                break
            }
            if checkV != v {
                isSame = false
                break
            }
        }
        if isSame {
            result = append(result, i)
        }
    }

	return result
}
```

运行结果
```
超出时间限制
64 / 65 个通过的测试用例
最后执行的输入
添加到测试用例
s =
"aaabb"
p =
"bb"
```

上面这个测试用例有点奇怪，明明很小，却说超时了，所以我又运行了一次
```
超出时间限制
34 / 65 个通过的测试用例
```
这次的s和p都是超级大的string(s有20098个字母，p有10036个)，这次感觉比较合理了，

现在leetcode多了一个功能，可以把没通过的用例直接添加到测试用例上面，这点点个赞！

我用vscode在本地测试了一下，耗时如下
```shell
-> % go run main.go
耗时 2.111329404s
-> % go run main.go
耗时 2.178508064s
```

耗时应该在构建两个map并且循环2个map上面，这里感觉可以优化一下，循环pInfoMap的时候，如果subStrInfoMap里面相等，其实可以把key删了，

但是删了key，又测试了一下时间没有快多少,然后我添加了一些日志，发现主要耗时在这块无意义的判断上面
```go
        subStrInfoMap := make(map[rune]int)
        for _, v := range subStr {
            _, ok := subStrInfoMap[v]
            if ok {
                subStrInfoMap[v] += 1
            } else {
                subStrInfoMap[v] = 1
            }
        }
```
这里ok的判断会导致耗时在2s左右，把ok删除了，并且把后续代码注释了，发现时间可以缩短到1s左右

然后在看一下ok的判断，发现这里是纯纯的浪费时间，完全等价于
```go
        subStrInfoMap := make(map[rune]int)
        for _, v := range subStr {
            subStrInfoMap[v] += 1
        }
```
因为go在初始化int的时候，有默认值就是0，这里直接+1就行

完整代码如下
```go
func findAnagrams(s string, p string) []int {
    result := make([]int, 0)
	if len(s) < len(p) || len(p) == 0{
		return result
	}
    pInfoMap := make(map[rune]int)
    for _, v := range p {
        _, ok := pInfoMap[v]
        if ok {
            pInfoMap[v] += 1
        } else {
            pInfoMap[v] = 1
        }
    }

    for i := range len(s) - len(p) + 1{
		endIndex := i + len(p)
        // 获取当前的字母串subStr
        subStr := s[i:endIndex]
        // 比较substr是否和p相等，问题变成比较两个字符串是否“相等”
        subStrInfoMap := make(map[rune]int)
        for _, v := range subStr {
            subStrInfoMap[v] += 1
        }
        // 把字符串的比较，转化为两个map的比较
        if len(pInfoMap) != len(subStrInfoMap) {
            continue
        }
        isSame := true
        for k, v := range pInfoMap {
            checkV, ok := subStrInfoMap[k]
            if !ok {
                isSame = false
                break
            }
            if checkV != v {
                isSame = false
                break
            }
            delete(subStrInfoMap, k)
        }
        for k, v := range subStrInfoMap {
            checkV, ok := pInfoMap[k]
            if !ok {
                isSame = false
                break
            }
            if checkV != v {
                isSame = false
                break
            }
        }
        if isSame {
            result = append(result, i)
        }
    }

	return result
}
```

运行结果
```
执行用时分布
1820 ms 击败5.01%

消耗内存分布
9.24MB 击败5.01%
```


### golang代码2

看完官方的解答，发现思路其实是一样的，但是我上面用map记录太耗费时间和内存了，

官方题目说明了全是小写字母，所以可以用一个list来替代掉map


```go
func findAnagrams(s string, p string) []int {
	sLen := len(s)
	pLen := len(p)
    result := make([]int, 0)
	if sLen < pLen || pLen == 0{
		return result
	}
	// 由于题目说了，字母的范围只有26个小写字母，并且26个小写字母的ASCII码值都是连续的
	// a -> 97
	// z -> 122
	// 所以可以用一个长度为26的数组来记录p的每个字母出现的次数,以及滑动窗口下s的部分
	var pCount, tmpSCount [26]int
	
	// 记录初始状态下字母的记录，这里就是滑动窗口左边对齐时的情况
	for i := 0; i < pLen; i++ {
		pCount[p[i]-'a']++
		tmpSCount[s[i]-'a']++
	}
	// 注意，如果是slice就不行，make([]int, 26)声明的不可以这样==对比
	if pCount == tmpSCount {
		result = append(result, 0)
	}
	// 到目前为止，滑动窗口已经已经左边对齐了，接下来就是开始滑动
	// 还是从0下标开始，到sLen - pLen结束
	for i, v := range s[:sLen-pLen] {
		// 最左边之前已经加过了，所以要减去1
		tmpSCount[v-'a']--
		// 最右边的字母
		leftChart := s[i+pLen]
		tmpSCount[leftChart-'a']++
		if pCount == tmpSCount {
			result = append(result, i+1)
		}
	}

	return result
}
```

运行结果
```
执行用时分布
0ms 击败100.00%

消耗内存分布
6.67MB 击败66.01%

```

我本地测试了一下耗时，确实超级无敌的多,从秒级别，变成了纳秒级，快了5000多倍，巨大优化（🤪）
```
-> % go run main.go
整体耗时 344.751µs
-> % go run main.go
整体耗时 370.002µs
```



### python代码1

下面跟进golang代码2翻译成python

```python
class Solution:
    def findAnagrams(self, s: str, p: str) -> List[int]:
        s_len = len(s)
        p_len = len(p)
        result = []
        if s_len < p_len or p_len == 0:
            return result
        p_count, s_count = [0]*26, [0]*26
        for i in range(p_len):
            p_count[ord(p[i]) - ord('a')] += 1
            s_count[ord(s[i]) - ord('a')] += 1
        if p_count == s_count:
                result.append(0)
        for k,v in enumerate(s[:s_len-p_len]):
            s_count[ord(v) - ord('a')] -= 1
            left_chart = s[k+p_len]
            s_count[ord(left_chart) - ord('a')] += 1
            if p_count == s_count:
                result.append(k+1)
        return result
```

运行结果
```
执行用时分布
27ms 击败87.86%

消耗内存分布
18.22MB 击败28.60%
```


欢迎来github上看更多题目的解答[力扣解题思路](https://github.com/WRAllen/LeetCode)
