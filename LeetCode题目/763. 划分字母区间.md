# 题目[763. 划分字母区间](https://leetcode.cn/problems/partition-labels/description/?envType=study-plan-v2&envId=top-100-liked)

给你一个字符串 s 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。例如，字符串 "ababcc" 能够被分为 ["abab", "cc"]，但类似 ["aba", "bcc"] 或 ["ab", "ab", "cc"] 的划分是非法的。

注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 s 。

返回一个表示每个字符串片段的长度的列表。

 

示例 1：
    输入：s = "ababcbacadefegdehijhklij"
    输出：[9,7,8]
    解释：
    划分结果为 "ababcbaca"、"defegde"、"hijhklij" 。
    每个字母最多出现在一个片段中。
    像 "ababcbacadefegde", "hijhklij" 这样的划分是错误的，因为划分的片段数较少。 
示例 2：

    输入：s = "eccbbbbdec"
    输出：[10]
 

提示：

    1 <= s.length <= 500
    s 仅由小写英文字母组成

*****

# 解题思路

理解一下题目的意思，也就是说，一个字符串如果分为str1，str2，那么str1里面存在的字符就不能出现在str2里面，同理str2的也不能出现在str1里

并且还要尽量的多分，比如可以分为str1~3,也可以分str1～2,那就要返回3个的情况

看到最多，之类的应该要想到贪心算法（好吧我承认，其实我从100到里面点进去的时候就看到了） 先复习一下[5大基础算法-贪心算法](../算法总结/5大基本算法.md)

但是不知道怎么贪，于是先写暴力破解的方法

## 解法1 暴力破解:
    
比如一个字符串："ababcbacadefegdehijhklij"，如果是人工进行处理，会怎么搞呢？

那肯定是一个一个试，比如我先从头a开始，把他当作是一个子字符串，然后是b，也作为一个字符串，每个字符串用一个字典记录存储了哪些字母

然后又是a，发现之前第一个子字符，包含了a了，所以aba现在肯定是一个字符串（b被两个a包围了，由于a都要在一起，所以b被绑架了）

这个时候变成一个字符串aba,然后继续，发现又是b，b又出现在之前aba里，所以，abab时一个字符串

下面接上推演过程
```
abab 遇到 c 变成 abab，c
abab，c  遇到b 变成 ababcb
ababcb 遇到a 变成 ababcba
ababcba 遇到c 变成 ababcbac
ababcbac 遇到a 变成 ababcbaca
ababcbaca 遇到d 变成 ababcbaca，d
ababcbaca，d 遇到e 变成 ababcbaca，d ，e
ababcbaca，d ，e 遇到f 变成 ababcbaca，d ，e，f
ababcbaca，d ，e，f 遇到e 由于e f e，所以f被绑定了 变成 ababcbaca，d ，efe
ababcbaca，d ，efe 遇到g 变成 ababcbaca，d ，efe，g
ababcbaca，d ，efe，g 遇到d 由于d在前面出现了，所以变成 ababcbaca，defegd
后面同理遇到e，在第二个子字符串上，变成ababcbaca，defegde
最后一步一步变成 "ababcbaca"、"defegde"、"hijhklij"
```

bingo通过人工模拟知道了处理流程，每次都想把字母独立出来，作为结果。

按上面的模拟过程，有个数组，数组里面的key为字母，value为字母出现的次数（结果要字符串长度）

一个字典代表一个字符串（因为只要长度，所以顺序无所谓），每次处理数据的时候，遍历这个数组，然后判断当前字母是否在这个字典的key里

如果数组都遍历完，都不存在，就把当前字母作为一个新的字符串。

大致流程如上，下面代码环节～


### golang代码

```go
func partitionLabels(s string) []int {
	// for循环当个字母的时候时rune，也就是int
    info := make([]map[rune]int, 0)
    for _, each := range s {
		if len(info) == 0 {
			dict := make(map[rune]int, 0)
			dict[each] = 1
			info = append(info, dict)
			continue
		}
		needMerge := false
		startIndex := 0
		for i := range(len(info)){
			dict := info[i]
			if _, ok := dict[each]; ok {
				needMerge = true
				startIndex = i
				break
			} else {
				continue
			}
		}
		// 不管他要不要merge，先append到列表末尾
		info = append(info, map[rune]int{each: 1})
		if needMerge {
			info = changeList(info, startIndex)
		}
	}
	result := make([]int, 0)
	for i := range info{
		total := 0 
		for _, v := range info[i]{
			total += v
		}
		result = append(result, total)
	}
	return result
}

func changeList(info []map[rune]int, startIndex int) []map[rune]int {
	needMergeList := info[startIndex:]
	// 截断info
	info = info[:startIndex]
	newDict := make(map[rune]int, 0)
	for _, dict := range needMergeList{
		for k, v := range dict {
			newDict[k] += v
		} 
	}
	info = append(info, newDict)
	return info
}
```

运行结果
```
执行用时分布
22ms 击败2.16%

消耗内存分布
8.38MB 击败5.08%
```

我靠，效率这么低的吗，不管了先复习一下python和预习一下rust的写法:D

### python代码

翻译为python

```python
class Solution:
    def partitionLabels(self, s: str) -> List[int]:
        info = []
        for char in s:
            if len(info) == 0:
                info.append({char: 1})
                continue
            need_merge = False
            start_index = 0
            for i in range(len(info)):
                dict = info[i]
                if char in dict:
                    start_index = i
                    need_merge = True
                else:
                    continue
            info.append({char:1})
            if need_merge:
                info = self.change_list(info, start_index)
        result = []
        for each in info:
            total = 0
            for v in each.values():
                total += v
            result.append(total)
        return result
                

    def change_list(self, info, start_index):
        need_merge_list = info[start_index:]
        info = info[:start_index]
        new_dict = {}
        for each in need_merge_list:
            for k, v in each.items():
                if k in new_dict:
                    new_dict[k] += v
                else:
                    new_dict[k] = v
        info.append(new_dict)
        return info
```

运行结果
```
执行用时分布
39ms 击败5.95%

消耗内存分布
19.04MB 击败5.13%
```

### rust代码

rust来咯

```rust
use std::collections::HashMap;
struct Solution;

impl Solution {
    pub fn partition_labels(s: String) -> Vec<i32> {
        // 因为rust里面单个字母是char类型
        let mut info: Vec<HashMap<char, i32>> = Vec::new();
        for each in s.chars(){
            if info.is_empty() {
                let mut first  = HashMap::new();
                first.insert(each, 1);
                info.push(first);
                continue;
            }
            let mut need_merge = false;
            let mut start_index = 0;
            for (i, dict) in info.iter().enumerate(){
                if let Some(_v) = dict.get(&each) {
                    start_index = i;
                    need_merge = true;
                    break;
                } else {
                    continue;
                }
            }
            // 下面这个更rust
            // for i in 0..info.len() {
            //     if info[i].contains_key(&ch) {
            //         start_index = i;
            //         need_merge = true;
            //     }
            // }
            let mut new_dict = HashMap::new();
            new_dict.insert(each, 1);
            info.push(new_dict);
            if need_merge {
                info = Self::change_list(info, start_index);
            }
        }
        let mut result: Vec<i32> = Vec::new();
        for each_dict in info{
            let mut total = 0;
            for v in each_dict.values(){
                total += v
            }
            result.push(total);
        }
        result
    }

    // 这里是mut info,不是&mut info说明这个函数返回一个新的info，而不是在旧的info上修改，如果是&mut info就可以不要返回值了
    pub fn change_list(mut info: Vec<HashMap<char, i32>>, start_index: usize) -> Vec<HashMap<char, i32>>{
        let need_merge_list: Vec<HashMap<char, i32>> = info[start_index..].to_vec();
        // 从start_index(包含)开始截断info
        info.truncate(start_index);
        let mut new_dict: HashMap<char, i32> = HashMap::new();
        for each_dict in need_merge_list{
            for (k, v) in each_dict{
                *new_dict.entry(k).or_insert(0) += v;
            }
        }
        info.push(new_dict);
        info
    }
}
```

运行结果
```
执行用时分布
7ms 击败10.00%

消耗内存分布
2.31MB 击败5.00%
```


## 解法2 贪心算法:

核心就是《每步都选择局部最优解》但是现在问题是，不知道要怎么选呀:(

看一下官方解答，写的是个啥... 只好把代码给gpt，让gpt老师来教我了

官方例子里面，最重要的start和end，我感觉他说的不是很清楚，下面我们整理一下官方描述

1. 首先由于一个字母，肯定只能在一个子字符串里面，也就是字母出现的第一次和最后一次，一定要在一个子字符串里面

2. 那我们就需要知道每个字母他出现的最后位置


### golang代码

具体代码如下，和官方的是一模一样的，加上了便于理解的注释

```go
func partitionLabels(s string) []int {
	// 存储每个字母出现的最后下标
	info := make(map[rune]int, 0)
	for i, c := range s{
		info[c] = i
	}
	result := make([]int, 0)
	// 子字符串的开始和结尾下标
	s_index, e_index := 0, 0
	for i, c := range s{
		// 如果当前字母的最后出现的位置，比结尾下标大，那说明子字符串肯定要在这个最后位置后面（包含）
		// 这里有个非常妙的地方
		// 比如： 第一个字母的最后一位是10，e_idnex=10
		// 第二个字母的最后一位如果比上面的10大，那e_index就更新到这个字母的最后一位
		// 这样可以保证s_index～e_index里面的字母都是符合条件的
		// 因为这个时候e_index是里面所有字母里面最后面的那个
		if info[c] > e_index {
			// 这样，这次这个子字符串的结尾就找到了
			e_index = info[c]
		}
		if i == e_index {
			// 因为是下标，所以+1
			result = append(result, e_index - s_index + 1)
			s_index = e_index + 1
		}
	}
	return result
}

```

运行结果
```
执行用时分布
0ms 击败100.00%

消耗内存分布
4.01MB 击败35.47%
```

上面的`info[c] > e_index`就是本道题目贪心算法最关键的一步，选择局部最优解，这里的最优解就是直接根据最后出现位置截断这个字符串


### python代码

翻译为python

```python
class Solution:
    def partitionLabels(self, s: str) -> List[int]:
        info = {}
        for i, c in enumerate(s):
            info[c] = i
        s_i, e_i = 0, 0
        result = []
        for i, c in enumerate(s):
            if info[c] > e_i:
                e_i = info[c]
            if i == e_i:
                result.append(e_i-s_i+1)
                s_i = e_i + 1
        return result
        
```

运行结果
```
执行用时分布
3ms 击败96.99%

消耗内存分布
19.13MB 击败5.05%
```


### rust代码

rust来咯！

```rust
use std::collections::HashMap;

impl Solution {
    pub fn partition_labels(s: String) -> Vec<i32> {
        let mut info = HashMap::new();
        for (i, c) in s.chars().enumerate(){
            info.insert(c, i);
        }
        // 也可以这样写
        // let (mut s_i, mut e_i) = (0usize, 0usize);
        // rust是可以在值后面加上类型的哦，例如0i32,0usize
        let mut s_i = 0usize;
        let mut e_i = 0usize;
        let mut result = Vec::new();
        // 这里的i是usize
        for (i, c) in s.chars().enumerate(){
            if info[&c] > e_i{
                e_i = info[&c];
            }
            if i == e_i {
                result.push((e_i-s_i+1) as i32);
                s_i = e_i + 1;
            }
        }
        result
    }
}
```

运行结果
```
执行用时分布
0ms 击败100.00%

消耗内存分布
2.14MB 击败52.50%
```

感觉自己越来越熟练rust了呢 :D

欢迎来github上看更多题目的解答[力扣解题思路](https://github.com/WRAllen/LeetCode)
