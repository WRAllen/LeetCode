# 题目[560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/description/?envType=study-plan-v2&envId=top-100-liked)

给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。

子数组是数组中元素的连续非空序列。

 

示例 1：

    输入：nums = [1,1,1], k = 2
    输出：2

示例 2：

    输入：nums = [1,2,3], k = 3
    输出：2
 

提示：

    1 <= nums.length <= 2 * 104
    -1000 <= nums[i] <= 1000
    -107 <= k <= 107

*****

# 解题思路

看起来也是一个滑动窗口的题目，只不过这个窗口的长度的可变长的

## 解法1 滑动窗口:

按照题目的意思，可以用两个下标循环nums数组，第一个下标从0开始到结束，第二个下标从上一个下标+1开始

由于测试过程中发现有一些特殊的case如下
```
1, -1, 0 k=0
0, 0  k=0
```
所以不遍历完整个列表是没法知道结果的，因为之前没考虑到负数的情况所以还打算剪枝删掉一部分便利逻辑

但是测试没通过，才发现还有负数和0的情况

### golang代码1

下面其实就是暴力破解，每个字段遍历2遍，进行找到符合条件的结果

```go
func subarraySum(nums []int, k int) int {
    result := 0
    tmpSumNums := make([]int, 0)
    for i := range nums{
        num := nums[i]
        if len(tmpSumNums) > 0 {
            lastNum := tmpSumNums[len(tmpSumNums)-1]
            if lastNum + k == 0 {
                tmpSumNums = append(tmpSumNums, 0)    
            } else {
                tmpSumNums = append(tmpSumNums, lastNum)
            }
        }else {
            tmpSumNums = append(tmpSumNums, num)
        }
        if tmpSumNums[len(tmpSumNums)-1] == k {
            result += 1
        }
    }
    return result
}

```

运行结果
```
执行用时分布
1461ms 击败5.02%

消耗内存分布
8.05MB 击败95.84%
```

这里python的暴力破解过不了，不写了

## 解法2 前序和:

### golang代码1

看到这个运行时间就知道肯定有不用遍历2次的方法

如果有少遍历的话，那一定要多存储（空间换时间，时间换空间，能量守恒🤪）

这里有点类似动态规划思路，要想只遍历一遍，那肯定要有个存储介质来存储信息，下面的解法个人感觉第一次做这种类型的很难想到

假如你有个数组，数组里面每个值都是当前nums的最大和

比如:[1, 1, 1]
那这个动态数组array就是：[1, 2, 3]
                       i     j
如果`array[j]-array[i]`等于k，是不是说明i+1到j里面的值相加正好等于k，

利用数学移动等价的原理：`array[j]-k`等于array[i]，然后当前array[j]其实就是当前的最大值，array[i]是之前的值

所以我们需要一个map来存储信息，把检索从O(n)变成O(1)，这个map用来存储当前最大值在出现的次数

具体看如下代码

```go
func subarraySum(nums []int, k int) int {
    result := 0
	// 动态最大值，其实是个list，但是只用最后一位，所以用一个int就行
    PreMaxNum := 0
	// key为当前动态最大值PreMaxNum，values为在map里面出现的次数
	infoMap := map[int]int{}
    for i := range nums{
		// map里面记录一下当前动态最大值PreMaxNum对应的次数（这里由于有负数，所以最大值可能是0 到某个值 再到 0，所以用+=1）
		// 这里这个顺序要再下面map的判断前，不然就需要多一行的初始化infoMap[0] = 1
		infoMap[PreMaxNum] += 1
		// 更新当前最大值
		PreMaxNum += nums[i]
		// 下面这里是关键逻辑，如果当前动态最大值PreMaxNum-k存在于map，（也就是上面的array[j]-k）说明之前至少存在过一个下标j
		// 使得当前的值减去j坐标的值等于k，所以result+=map对应valuse的值
		if _, ok := infoMap[PreMaxNum-k]; ok {
			result += infoMap[PreMaxNum-k]
		}
		
    }
    return result
}
```

运行结果
```
执行用时分布
15ms 击败60.52%

消耗内存分布
9.02MB 击败65.91%
```

### python代码1

把go翻译成python，用一个默认值的dict：defaultdict
如果key不存在defaultdict会自动创建一个value为默认值的

```python
from collections import defaultdict

class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        result, pre_max_num = 0, 0
        # from collections import defaultdict
        info_map = defaultdict(int)
        for num in nums:
            info_map[pre_max_num] += 1
            pre_max_num += num
            if pre_max_num-k in info_map:
                result += info_map[pre_max_num-k]
                
        return result

```

运行结果
```
执行用时分布
39ms 击败79.18%

消耗内存分布
20.17MB 击败57.42%
```


欢迎来github上看更多题目的解答[力扣解题思路](https://github.com/WRAllen/LeetCode)
