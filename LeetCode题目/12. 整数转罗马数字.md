# 题目[12. 整数转罗马数字](https://leetcode-cn.com/problems/integer-to-roman/)

罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。

字符          数值
I             1
V             5
X             10
L             50
C             100
D             500
M             1000

例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

    I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
    X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
    C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。

给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。

示例 1:

输入: 3
输出: "III"

示例 2:

输入: 4
输出: "IV"

示例 3:

输入: 9
输出: "IX"

示例 4:

输入: 58
输出: "LVIII"
解释: L = 50, V = 5, III = 3.

示例 5:

输入: 1994
输出: "MCMXCIV"
解释: M = 1000, CM = 900, XC = 90, IV = 4.

*****

# Python解题思路

看到题目马上想到的就是要把特殊的情况和对应得字符对应起来
因为题目说不会超过3999（也就是最多千位），所以设置一个compare_base = 1000 来依次取 千位 百位 十位 个位 进行比较

```python
class Solution:
    def intToRoman(self, num: int) -> str:
        RomanDict = {
            1: "I",
            4: "IV",
            5: "V",
            9: "IX",
            10: "X",
            40: "XL",
            50: "L",
            90: "XC",
            100: "C", 
            400: "CD",
            500: "D",
            900: "CM",
            1000: "M"
        }
        compare_base = 1000
        result_str = ""
        while compare_base >= 1:
            tem_num = int(num / compare_base % 10)
            # 对应位上的数值不为空时
            if tem_num != 0:
                tem_num = int(tem_num*compare_base)
                # 获取对应关系里面小于当前数的最大的key
                key = max([ each for each in RomanDict.keys() if each <=  tem_num])
                # 需要填充的值 例如 3 需要在I 后面填充两个 I
                need_fill = int((tem_num - key) / compare_base) * RomanDict[compare_base]
                result_str += RomanDict[key] + need_fill
            compare_base = compare_base / 10
        return result_str
```

运行结果

```
执行用时 :72 ms, 在所有 python3 提交中击败了55.24% 的用户
内存消耗 :14 MB, 在所有 python3 提交中击败了5.26%的用户

执行用时 :100 ms, 在所有 python3 提交中击败了16.58% 的用户
内存消耗 :14.1 MB, 在所有 python3 提交中击败了5.26%的用户

执行用时 :84 ms, 在所有 python3 提交中击败了28.74% 的用户
内存消耗 :13.8 MB, 在所有 python3 提交中击败了5.26%的用户
```

就是这个执行的速度有点慢额，决定参（抄）考（袭）一下官方解答，看一下怎么提升速度
发现这道题竟然没有官方解答（2019-11-20 记录），于是转而看其他大神是怎么解答的

看了一下大神（liweiwei1419）的解题思路，发现之前自己写的就和ZZ一样，
这个贪心算法（又称贪婪算法）真是眼前一亮啊！

```python
class Solution:
    def intToRoman(self, num: int) -> str:
        # 把阿拉伯数字与罗马数字可能出现的所有情况和对应关系，放在两个数组中
        # 并且按照阿拉伯数字的大小降序排列，这是贪心选择思想
        nums = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
        romans = ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]

        index = 0
        res = ''
        while index < 13:
            # 注意：这里是等于号，表示尽量使用大的"面值"
            while num >= nums[index]:
                res += romans[index]
                num -= nums[index]
            index += 1
        return res
```

运行结果

```
执行用时 :76 ms, 在所有 python3 提交中击败了44.39% 的用户
内存消耗 :14.1 MB, 在所有 python3 提交中击败了5.26%的用户

执行用时 :60 ms, 在所有 python3 提交中击败了86.81% 的用户
内存消耗 :13.9 MB, 在所有 python3 提交中击败了5.26%的用户

执行用时 :68 ms, 在所有 python3 提交中击败了65.73% 的用户
内存消耗 :13.9 MB, 在所有 python3 提交中击败了5.26%的用户
```

速度的提升也是很明显的

百度结果：
贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。
贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。

自我总结一下贪心算法（又称贪婪算法）
尽可能的去匹配当前可以匹配到的数据

顺便抄一下五大算法

五大经典算法分为

1、分治法：把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。

2、动态规划法：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。

3、贪心算法：在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。

4、回溯法：回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。深度优先；

5、分支限界法：类似于回溯法，也是一种在问题的解空间树T上搜索问题解的算法。但在一般情况下，分支限界法与回溯法的求解目标不同。回溯法的求解目标是找出T中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。

