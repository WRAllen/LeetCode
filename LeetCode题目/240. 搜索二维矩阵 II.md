# 题目[240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/description/?envType=study-plan-v2&envId=top-100-liked)

编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：

    每行的元素从左到右升序排列。
    每列的元素从上到下升序排列。

示例 1：
![1](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg)
    
    输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5
    输出：true



示例 2：
![2](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid.jpg)

    输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20
    输出：false

*****

# 解题思路

一看就是一个高级版本的二分法

## 解法1 循环二分法:

既然他是一个二维数组，现在除了暴力的O(n*m)最简单的优化就是在每行的判断上面用二分法

### golang代码1

```go
func searchMatrix(matrix [][]int, target int) bool {
    for row := range matrix{
        if BinarySearch(matrix[row], target) {
            return true
        }
    }
    return false
}

// BinarySearch 二分搜素
func BinarySearch(matrix []int, target int ) bool {
    rIndex := len(matrix) - 1
    lIndex := 0
    for {
        i := (lIndex + rIndex ) / 2
        if matrix[i] == target {
            return true
        }
        // 边界条件，这里我之前还考虑LIndex是不是会大于len(matrix),rIndex是不是会小于0
        // 其实只要如下，保证他们不会交叉相等就行
        if lIndex >= rIndex {
            return false
        }
        if matrix[i] < target {
            lIndex = i + 1
        } else {
            rIndex = i - 1
        }
    }
}

```

运行结果
```
执行用时分布
23ms 击败8.65%

消耗内存分布
7.95MB 击败19.62%
```

但是上面的解法显然只用到了题目给的一个条件，每行是递增的，而每列递增这个条件没用上，说明肯定是有巨大的提升空间的


## 解法2 z字查找:

leetcode的官方的方法3说的，不是很清楚，下面引用[Krahets](https://leetcode.cn/u/jyd/)大神的解题思路就能很好的理解官方的方法3

K神的[解题思路](https://leetcode.cn/problems/search-a-2d-matrix-ii/solutions/2361487/240-sou-suo-er-wei-ju-zhen-iitan-xin-qin-7mtf/?envType=study-plan-v2&envId=top-100-liked)

直接附上图片，和其思路

```
如下图所示，我们将矩阵逆时针旋转 45° ，并将其转化为图形式，发现其类似于 二叉搜索树 ，即对于每个元素，其左分支元素更小、右分支元素更大。因此，通过从 “根节点” 开始搜索，遇到比 target 大的元素就向左，反之向右，即可找到目标值 target 。
```

![1](https://pic.leetcode-cn.com/6584ea93812d27112043d203ea90e4b0950117d45e0452d0c630fcb247fbc4af-Picture1.png)

这样转一下就很好理解了，从矩阵的最右上角(x, y)(x是横坐标，y是纵坐标)判断，

如果当前的目标target要大，那y-1（比目标大说明在左边，所以y要-1），如果比target要小，那x+1（说明目标在右边，所以x要+1）

这样既用上了行的递增，也用上了列的递增


### golang代码1

```go
func searchMatrix(matrix [][]int, target int) bool {
    x := 0
    y := len(matrix[0])-1
    for x <= len(matrix)-1 && y >= 0{
        if matrix[x][y] == target {
            return true
        }
        if matrix[x][y] > target {
            y -= 1
        } else {
            x += 1
        }
    }
    return false
}
```

运行结果
```
执行用时分布
19ms 击败45.35%

消耗内存分布
7.82MB 击败93.05%
```

### python代码1

下面翻译为python版本

```python
class Solution:
    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:
        x = 0
        y = len(matrix[0]) - 1
        while x <= len(matrix) - 1 and y >= 0:
            if matrix[x][y] == target:
                return True
            if matrix[x][y] > target:
                y -= 1
            else:
                x += 1
        return False
        
```

运行结果
```
执行用时分布
211ms 击败7.34%

消耗内存分布
23.63MB 击败43.88%
```


欢迎来github上看更多题目的解答[力扣解题思路](https://github.com/WRAllen/LeetCode)
