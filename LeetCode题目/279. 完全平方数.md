# 题目[279. 完全平方数](https://leetcode.cn/problems/perfect-squares/description/?envType=study-plan-v2&envId=top-100-liked)

给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。

完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。

 

示例 1：

    输入：n = 12
    输出：3 
    解释：12 = 4 + 4 + 4
示例 2：

    输入：n = 13
    输出：2
    解释：13 = 4 + 9
 
提示：

    1 <= n <= 104

*****

# 解题思路

刚开始想的是，把n先开个平方根，求出x，然后判断n-x*x得值，然后再把这个值，递归调用一下

因为这个x肯定是里面最大的，毕竟x+1的平方就超过n了。

后面发现这种思路应该是不行的，比如拿12来说

x是3，那12-3*3=3，这个3 只能拆成1，1，1，那就有4个完全平方数了，

但是他最少的case是4 + 4 + 4，只有3个完全平方数，所以这种想法是不行的

其实上面这种思路有点贪心算法的意思（可能因为做的上一题是贪心算法相关的）

暂时没啥思路，看一下[官方的解答](https://leetcode.cn/problems/perfect-squares/solutions/822940/wan-quan-ping-fang-shu-by-leetcode-solut-t99c/?envType=study-plan-v2&envId=top-100-liked)

我靠，竟然可以用动态规划，看来是太久没做动态规划了，复习一下[动态规划](../算法总结/动态规划算法合集.md)

新添加[动态规划和贪心的对比](../算法总结/动态规划和贪心算法的区别.md)，正好把这题加进去



## 解法1 动态规划:

既然是动态规划，那我们就要知道一定有个dp数组，并且dp数组里面的dp[n]就是我们要的结果。

那这个dp数组里面存储啥呢？那当然是存储n时最小次数的完全平方数了！

所以dp[1] 就是当n为1时，最小次数的完全平方数，dp[12]就是当n为12时，最小次数的完全平方数。

并且dp数组，一定求区dp[n]时，一定和dp[n-x]有关系，这里的x可以时1，也可以是其他，这题显然x不是1

基于最早的尝试，我们知道如果i*i=n时是最好的结果，但是这里也是一个循环的判断条件，毕竟如果i+1的话，就超过了n了

所以里面肯定有一个循环，让i从1～i*i<n

那怎么求dp[n]呢？那必然要都试一下才知道，让i从1开始，一直到i*i<n, 

dp[n] = dp[n-i*i] + 1 (n-i*i其实就是求n减去这个i剩下的数的最小次数平方数)

但是上面这个公式是不对的，因为i是从1～i*i<n, 但是题目要求最小，也就是当要求n的时候，其实i从1～i*i<n都的试一下才行

直接上代码（来自官方解题思路）


### golang代码

```go
func numSquares(n int) int {
	// 这里由于n不会为0，所以从1开始，dp为n+1个长度
	dp := make([]int, n+1)
	
	for i := 1; i <= n; i ++ {
		// 虽然n最大是10000，这里先取32位保险点
		minNum := math.MaxInt32
		for j := 1; j * j <= i; j++{
			// go1.21自带min,max（我本地的1.24.2）
			minNum = min(minNum, dp[i-j*j])
		}
		// 取之前最小的情况，加上当前j从1～j*j<i的某一次结果，具体j是几的时候minNum取最小无所为
		// 反正就是能依靠dp，找到j为x时，最小的情况，再加上j*j这次的1
		dp[i] = minNum + 1
	}

	return dp[n]
}
```

运行结果
```
执行用时分布
20ms 击败79.87%

消耗内存分布
7.79MB 击败56.27%
```

### python代码

照常翻译为python，go写多了，老是把python写成go的样子，无语了都

```python
class Solution:
    def numSquares(self, n: int) -> int:
        dp = [0] * (n + 1)
        for i in range(1, n+1):
            min_num = float('inf')
            # 没有类似go的for j := 1; j * j <= i; j++ 这里用while替代
            y = 1
            while y * y <= i:
                min_num = min(min_num, dp[i-y*y])
                y += 1
            dp[i] = min_num + 1
        return dp[n]
```

运行结果
```
执行用时分布
1812ms 击败68.00%

消耗内存分布
19.25MB 击败29.59%
```

### rust代码

rust来啦

```rust
impl Solution {
    pub fn num_squares(n: i32) -> i32 {
        let n = n as usize;
        // 下面这样是创建空的数组
        // let mut dp: Vec<i32> = Vec::new();
        // 下面这样是创建有默认值的数组
        let mut dp = vec![0; n + 1];
        for i in 1..n+1{
            let mut min_num = i32::MAX;
            let mut y = 1;
            while y * y <= i {
                // 和py和go的min和max不同，这里的这些方法可以直接变量.出来
                min_num = min_num.min(dp[i-y*y]);
                y += 1;
            }
            dp[i] = min_num + 1;
        }
        dp[n]
    }
}
```

运行结果
```
执行用时分布
15ms 击败82.50%

消耗内存分布
2.27MB 击败61.25%
```

这题是非常经典的能区分贪心算法和动态规划的一题，点个赞～

欢迎来github上看更多题目的解答[力扣解题思路](https://github.com/WRAllen/LeetCode)
