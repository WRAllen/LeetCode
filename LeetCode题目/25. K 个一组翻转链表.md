# 题目[25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。

k 是一个正整数，它的值小于或等于链表的长度。

如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。

示例 :

给定这个链表：1->2->3->4->5

当 k = 2 时，应当返回: 2->1->4->3->5

当 k = 3 时，应当返回: 3->2->1->4->5

说明 :

    你的算法只能使用常数的额外空间。
    你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

******

# python解题思路

这道题难就难在K个分组，毕竟如果没有分组的话我已经做了[206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)（滑稽）

题目要求只能有常数的额外空间，这就断送了我想通过遍历然后创建新链表的念头，也就是只能在源链表上进行操作咯

递归三部曲

1.**递归终止条件** 遍历到最后一个节点，或者剩下的节点满足不了k

2.**本次递归做什么** 做什么无非就是题目说的那样，不过只是一次的行为，

> 例如：题目说翻转3个为一组的链表, 链表为[1, 2, 3, 4, 5, 6 ....] 那也就是翻转 [3, 2, 1] 然后再接上[4, 5, 6 ....] 至于后面的节点怎么做就先不用考虑，因为迭代它会帮我们做（滑稽）

3.**返回什么** 返回头节点，一般迭代返回的变量都是一样的， 大胆猜测就是题目参数里面的head

下面呈现完整代码（未优化，但是能通过测试）

```python
class Solution:
    def reverseKGroup(self, head: ListNode, k: int) -> ListNode: 
        # 递归终止条件之一：如果遇到空节点就返回空 
        if not head: return None
        tem = head
        count = 0
        # 开始向后进行遍历，遍历k次
        while tem:
            tem = tem.next
            count += 1
            if count == k: break
        # 相等则证明此时链表里面有至少k个节点，下面进行前k个节点的交换
        if count == k:
            # 这里的想法非常简单
            # 例如： [1, 2, 3, 4, 5] k = 3 的时候
            # 因为前面已经遍历了3次 所以现在的tem是指向4的
            # 因为是递归，所以4后面的链表自然我们是不用管的，于是直接递归
            tem = self.reverseKGroup(tem, k)
            # 这里就是我们本次递归做什么了，结合上面的例子，那就是交换[1, 2, 3]的位置
            while count:
                # 节点2 因为后面的交换会丢失 节点2 的地址，于是先保存下来
                second = head.next
                # 把 节点1 的next 设置为 递归的结果 也就是 1 -> 递归后的[4, 5, 6....]
                head.next = tem
                # 然后再把刚刚上面拼接后的 1 -> 递归后的[4, 5, 6....] 再赋予 tem
                tem = head
                # 这个时候有两个节点指向 递归后的[4, 5, 6....] 节点1 和 节点3
                # 但是节点3 没有关系，因为后面循环到了之后自然又会 指向最新的tem
                # 所以我们继续遍历， head 从节点1 移动到了节点2
                head = second
                # 进行3次之后 head 为空节点 tem就是最后的新链表
                count -= 1
            # 把循环遍历后的新链表赋予head
            head = tem
        # 递归终止条件之二：当然要结合上面的if判断 如果count != k 的时候
        # 也就是遍历完节点发现还没有k个，就直接返回头节点
        return head
```

运行结果

```
执行用时 :40 ms, 在所有 python3 提交中击败了99.93% 的用户
内存消耗 :13.5 MB, 在所有 python3 提交中击败了100.00%的用户

执行用时 :48 ms, 在所有 python3 提交中击败了97.23% 的用户
内存消耗 :13.7 MB, 在所有 python3 提交中击败了100.00%的用户

执行用时 :48 ms, 在所有 python3 提交中击败了97.23% 的用户
内存消耗 :13.5 MB, 在所有 python3 提交中击败了100.00%的用户
```

拿[1, 2, 3, 4, 5] k=3 的例子 对交换节点的具体思路做出解释

可以想象成是两个列表

 [1, 2, 3] [4, 5]

然后 把 [1, 2, 3] 里面的节点1 拿出来 指向 [4 ,5] 此时变成 [1, 4,  5]  另一个 [2, 3]

然把新的  [1, 4, 5] 当做是 [4, 5] 新的 [2, 3] 当做是[1, 2, 3]

再取 节点 2 重复上面的过程，因为k = 3所以只重复3次 

下面是节点的变化过程

```
1 -> 2-> 3 -> 4 ->5
count = 3 时：1 -> 4 -> 5        2 -> 3 -> 4 -> 5
count = 2 时：2 -> 1 -> 4 -> 5        3 -> 4 -> 5
count = 1 时：3 -> 2 -> 1 -> 4 -> 5        4 -> 5
这时跳出循环， 把 节点3 返回回去，就是新的链表
```

欢迎来github上看更多题目的解答[力扣解题思路](https://github.com/WRAllen/LeetCode)
