# 题目[108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/?envType=study-plan-v2&envId=top-100-liked)

给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 平衡 二叉搜索树。

 

示例 1：

![1](https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg)


    输入：nums = [-10,-3,0,5,9]
    输出：[0,-3,9,-10,null,5]
    解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：

示例 2：


![2](https://assets.leetcode.com/uploads/2021/02/18/btree2.jpg)


    输入：nums = [1,3]
    输出：[3,1]
    解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。
 

提示：

    1 <= nums.length <= 104
    -104 <= nums[i] <= 104
    nums 按 严格递增 顺序排列

*****

# 解题思路

二叉搜索树，就是node的左节点都比node的值小，右节点都比node的值大，同二分法

平衡二叉树 是指该树所有节点的左右子树的高度相差不超过 1。


## 解法1 递归二分法:

然后题目给的数值，右正好是递增的，那感觉是否可以，把nums分为 左边，中间，右边，然后当前的node的值就是中间

左边和右边用递归去处理，话不多说，代码如下

### golang代码1

```go
func sortedArrayToBST(nums []int) *TreeNode {
    // 由于切割列表，可能会出现空的情况，这里遇到直接返回
    if len(nums) == 0 {
        return nil
    }
    // 构建中间的node
    middleIndex := len(nums) / 2
    rootNode := &TreeNode{
    	Val:   nums[middleIndex],
    }
    // 左边的nums交给递归
    rootNode.Left = sortedArrayToBST(nums[:middleIndex])
    // 右边的nums也交给递归，递归真是一个靠谱的兄弟
    rootNode.Right = sortedArrayToBST(nums[middleIndex+1:])
    // 返回刚刚创建的中间node
    return rootNode
}
```

运行结果
```
执行用时分布
0ms 击败100.00%

消耗内存分布
5.09MB 击败48.23%
```

### python代码1

照常翻译为python

```python
class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        if len(nums) == 0:
            return None
        middle = len(nums) // 2
        node = TreeNode(val=nums[middle])
        node.left = self.sortedArrayToBST(nums[:middle])
        node.right = self.sortedArrayToBST(nums[middle+1:])
        return node
```

运行结果
```
执行用时分布
3ms 击败86.63%

消耗内存分布
18.81MB 击败33.91%
```


欢迎来github上看更多题目的解答[力扣解题思路](https://github.com/WRAllen/LeetCode)
