# 题目[1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

示例:

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]

*****

# python解题思路

暴力破解

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        for i, each_i in enumerate(nums):
            for j, each_j in enumerate(nums):
                if i == j:
                    continue
                else:
                    if(each_i+each_j) == target:
                        return [i, j]
                    else:
                        continue
```

运行结果：

```
！！！不通过！！！
```

上面这种方式是暴力破解，在测试数据（量小）的时候没有问题，遇到超大的量就出现问题，

时间复杂度 N^2

使用Hash映射（借助字典）-多消耗内存

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        b_list = [target - each for each in nums]
        new_dict = {}
        for i, each in enumerate(b_list):
            new_dict[each] = i
        for j, each in enumerate(nums):
            if(each in new_dict.keys()):
                if(j != new_dict[each]):
                    return [j, new_dict[each]]
```

运行结果：

```
执行用时 :76 ms, 在所有 python3 提交中击败了74.69% 的用户
内存消耗 :16.1 MB, 在所有 python3 提交中击败了5.05%的用户

执行用时 :56 ms, 在所有 python3 提交中击败了98.55% 的用户
内存消耗 :16 MB, 在所有 python3 提交中击败了5.05%的用户

执行用时 :68 ms, 在所有 python3 提交中击败了87.96% 的用户
内存消耗 :15.8 MB, 在所有 python3 提交中击败了5.05%的用户
```

上面这种是可以避免暴力破解 时间复杂度 N + N * 1 = 2N

不使用额外的空间-少消耗内存，增加了查询时间

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        for i, old in enumerate(nums):
            a = target - old
            if a in nums:
                index = nums.index(a)
                if index != i:
                    return [i, index]
```

运行结果：

```
执行用时 :1088 ms, 在所有 python3 提交中击败了31.84% 的用户
内存消耗 :14.8 MB, 在所有 python3 提交中击败了6.25%的用户

执行用时 :1184 ms, 在所有 python3 提交中击败了28.74% 的用户
内存消耗 :14.7 MB, 在所有 python3 提交中击败了7.08%的用户

执行用时 :1112 ms, 在所有 python3 提交中击败了31.56% 的用户
内存消耗 :14.9 MB, 在所有 python3 提交中击败了5.85%的用户
```

上面这种理论上时间复杂度是 N * python列表的查询时间（N） = N^2

使用Hash映射（借助字典）-的优化版

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        new_dict = {}
        for i, each in enumerate(nums):
            new_target = target - each
            if new_target in new_dict.keys():
                return [new_dict[new_target], i]
            else:
                new_dict[each] = i
```

运行结果：

```
执行用时 :64 ms, 在所有 python3 提交中击败了93.06% 的用户
内存消耗 :15 MB, 在所有 python3 提交中击败了5.05%的用户

执行用时 :68 ms, 在所有 python3 提交中击败了87.96% 的用户
内存消耗 :14.9 MB, 在所有 python3 提交中击败了6.02%的用户

执行用时 :64 ms, 在所有 python3 提交中击败了93.06% 的用户
内存消耗 :15 MB, 在所有 python3 提交中击败了5.05%的用户
```

上面这种理论上时间复杂度是 N * 1 = N

