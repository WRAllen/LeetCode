# 题目[1. 两数之和](https://leetcode-cn.com/problems/two-sum/)

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

示例:

```
给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
```



*****

# 前言（prelude）

这是我接触leetcode的第一题，看了一下git的记录，

是6年前做的，之前只会python，虽然我大学是学java的，但是第一份工作是python，那个时候我记得还是3.6之前的版本，过了6年都出到3.13了 :D

4年前加上了go，因为工作中要用到golang，刚开始写，好多基础都不会，那个时候也没有GPT这些，学习的过程还是挺艰难的

现在我要加上rust（2026.1.1），因为工作中又要用到rust，但是现在有gpt，deepseek，还有cursor这种，学习门槛是低了非常多（虽然rust还是挺难入门的）

我任务要学习一门新的语言，如果只是看他教程说的那些，不亲自去写一写，还是很容易忘记的，甚至不是只看教程重复的敲一遍，因为照着敲一边还是很容易忘记的。

感觉刷LeetCode是不错的方法，可以夯实基础数据结构的用法，等基础熟悉了，再去学习拓展的知识。

给自己定一下一个OKR，争取每天都刷一刷LeetCode，不管是不是新题 :D

# 解题思路

## 解法1 字典:

遍历每个元素的时候，用target-该元素，判断这个值在不在字典的key里面（python式dict，go是map，rust是HashMap，

如果在，说明之前遍历过这个值（改元素+之前的值=target）

如果不在，把值放入字典的key里面，为了后续不用遍历之前的列表，直接从字典里面判断就行（字典判断key的时间复杂度是O(1)）

ps：题目要返回下标，所以把value设置为下标


### golang代码

```go
func twoSum(nums []int, target int) []int {
    info := make(map[int]int, 0)
    for i := range nums{
        num := nums[i]
        oldVal := target - num
        v, ok := info[oldVal]
        if ok {
            return []int{i, v}
        } else {
            info[num] = i
        }
    }
    return nil
}
```

运行结果
```
执行用时分布
0ms 击败100.00%

消耗内存分布
5.79MB 击败18.72%
```

### python代码

把go的代码翻译为python

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        info = {}
        # 或者 for i, num in enumerate(nums):
        for i in range(len(nums)):
            old_val = target - nums[i]
            if old_val in info:
                return [i, info[old_val]]
            else:
                info[nums[i]] = i
        
```

运行结果
```
执行用时分布
4ms 击败44.86%

消耗内存分布
18.53MB 击败45.25%
```

### rust代码

来手打rust代码

```rust
// 字典的包，不在默认的use里面（不在prelude）
use std::collections::HashMap;

impl Solution {
    pub fn two_sum(nums: Vec<i32>, target: i32) -> Vec<i32> {
        let mut info = HashMap::new();
        // iter是把nums变成迭代器，enumerate同python的作用
        // rust编译器会自动推断遍历类型，这里的i是unsize，v是i32
        for (i, v) in nums.iter().enumerate() {
            // rust的变量名称snake_case风格，同python一样，但是注释同go
            let old_val = target - v;
            // 这里old_val必须用&, 用他的引用，不然后续再使用old_val时就会提示所有权被转移了
            // 这里rust的所有权和java，python，go，c#这些都不一样，可以具体去学习一下
            if info.contains_key(&old_val) {
                // 由于i是unsize，所以需要转成i32
                return vec![i as i32, info[&old_val]];
            } else {
                // rust里面 ; 不是“语句结束符”，而是“丢弃返回值”
                // 所以下面没有;就会被当作是return语句
                info.insert(v, i as i32);
            }
            // 上面这个还可以写的更rust
            // map的get会返回一个Option的值，表示可能为None
            // Some表示一定存在，然后下面是rust的匹配模式，会把j和old_val匹配上
            // if let Some(&j) = map.get(&old_val) {
            //     return vec![i as i32, j];
            // }
            // map.insert(num, i as i32);
        }
        // 这里同go一样，不写默认返回() 会编译不通过
        // rust里面的() 就是一个空的元组
        vec![]
    }
}
```

运行结果
```
执行用时分布
4ms 击败44.86%

消耗内存分布
18.53MB 击败45.25%
```

欢迎来github上看更多题目的解答[力扣解题思路](https://github.com/WRAllen/LeetCode)



<div align="center"><strong>下面是历史记录(我舍不得删)</strong></div>

----

# python解题思路

## 方法1：暴力破解

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        for i, each_i in enumerate(nums):
            for j, each_j in enumerate(nums):
                if i == j:
                    continue
                else:
                    if(each_i+each_j) == target:
                        return [i, j]
```

运行结果：

```
！！！不通过！！！
```

上面这种方式是暴力破解，在测试数据（量小）的时候没有问题，遇到超大的量就出现问题，

时间复杂度 N^2

## 方法2：字典

不使用额外的空间-少消耗内存，增加了查询时间

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        for i, old in enumerate(nums):
            a = target - old
            if a in nums:
                index = nums.index(a)
                if index != i:
                    return [i, index]
```

运行结果：

```
执行用时 :1088 ms, 在所有 python3 提交中击败了31.84% 的用户
内存消耗 :14.8 MB, 在所有 python3 提交中击败了6.25%的用户

执行用时 :1184 ms, 在所有 python3 提交中击败了28.74% 的用户
内存消耗 :14.7 MB, 在所有 python3 提交中击败了7.08%的用户

执行用时 :1112 ms, 在所有 python3 提交中击败了31.56% 的用户
内存消耗 :14.9 MB, 在所有 python3 提交中击败了5.85%的用户
```

上面这种理论上时间复杂度是 N * python列表的查询时间（N） 所以最终的时间复杂度= *O(n^2)*

使用Hash映射（借助字典）

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        new_dict = {}
        for i, each in enumerate(nums):
            new_target = target - each
            if new_target in new_dict.keys():
                return [new_dict[new_target], i]
            else:
                new_dict[each] = i
```

运行结果：

```
执行用时 :32 ms, 在所有 Python3 提交中击败了98.48% 的用户
内存消耗 :14.9 MB, 在所有 Python3 提交中击败了5.36%的用户

执行用时 :48 ms, 在所有 Python3 提交中击败了79.24% 的用户
内存消耗 :14.8 MB, 在所有 Python3 提交中击败了8.56%的用户

执行用时 :44 ms, 在所有 Python3 提交中击败了85.24% 的用户
内存消耗 :14.6 MB, 在所有 Python3 提交中击败了10.32%的用户
```

上面这种理论上时间复杂度是 N * 1 = N

# Go解题思路

## 方法1:利用字典

思路同python的方法1，也是利用一个额外的字典来存储数据，这样避免了二次遍历

```go
func twoSum(nums []int, target int) []int {
    tmp := make(map[int]int)
    for i, num := range nums{
        new_target := target - num
        index, ok := tmp[new_target]
        if ok{
            return []int{i, index}
        }else{
            tmp[num] = i
        }
    }
    return []int{}
}
```

运行结果

```shell
执行用时：4 ms, 在所有 Go 提交中击败了97.87% 的用户
内存消耗：4.2 MB, 在所有 Go 提交中击败了57.87% 的用户
```

欢迎来github上看更多题目的解答[力扣解题思路](https://github.com/WRAllen/LeetCode)
