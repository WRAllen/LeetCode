# 题目[199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/description/?envType=study-plan-v2&envId=top-100-liked)

给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

 

示例 1：


    输入：root = [1,2,3,null,5,null,4]
    输出：[1,3,4]

解释：


![1](https://assets.leetcode.com/uploads/2024/11/24/tmpd5jn43fs-1.png)



示例 2：

    输入：root = [1,2,3,4,null,null,null,5]

    输出：[1,3,4,5]

解释：


![2](https://assets.leetcode.com/uploads/2024/11/24/tmpkpe40xeh-1.png)


示例 3：

    输入：root = [1,null,3]

    输出：[1,3]

示例 4：

    输入：root = []

    输出：[]

 

提示:

    二叉树的节点个数的范围是 [0,100]
    -100 <= Node.val <= 100 

*****

# 解题思路

题目的意思其实就获取每层的最右的节点

## 解法1 层次遍历:

层次遍历后，取每层的最右边就是答案

### golang代码1

直接层次遍历起手～

```go

var info [][]int

func rightSideView(root *TreeNode) []int {
    // 这里必须初始化，不让leetcode跑多条测试的时候，会一直往里面追加数据
    info = [][]int{}  
    DFS(root, 0)
    result := make([]int, 0)
    for i := range info{
        eachRow := info[i]
        if len(eachRow) > 0{
            result = append(result, eachRow[len(eachRow)-1])
        }
    }
    return result
}

func DFS(root *TreeNode, level int) {
    if root == nil {
        return
    }
    if level == len(info){
        info = append(info, make([]int, 0))
    }
    info[level] = append(info[level], root.Val)
    DFS(root.Left, level+1)
    DFS(root.Right, level+1)
}
```

`info = [][]int{}  `很重要啊，之前没这样搞，才发现leetcode是把你代码copy一份到他的运行环境

然后根据参数，不停的去执行对应的函数，这里就是`rightSideView`但是由于info又是global的，

所以上次运行的结果还会存储在里面，数据越来越奇怪

PS：执行测试用例的时候发现，case3里面明明没有4，5，却在结果里面看到了，才发现这个，当然也可以不要global的参数

运行结果
```
执行用时分布
0ms 击败100.00%

消耗内存分布
4.13MB 击败58.50%
```

### python代码1

话不多说，翻译为python，去除掉global的变量

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
        info = []
        self.DFS(root, 0, info)
        result = []
        for eachRow in info:
            result.append(eachRow[-1])
        return result
    
    def DFS(self, root, level, info):
        if root is None:
            return
        if len(info) == level:
            info.append([])
        info[level].append(root.val)
        self.DFS(root.left, level+1, info)
        self.DFS(root.right, level+1, info)

```

运行结果
```
执行用时分布
0ms 击败100.00%

消耗内存分布
17.71MB 击败13.40%
```


欢迎来github上看更多题目的解答[力扣解题思路](https://github.com/WRAllen/LeetCode)
